<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="dns-prefetch" href="https://kkewwei.github.io/elasticsearch_learning">
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一个一直向阳的人">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://kkewwei.github.io/elasticsearch_learning/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一个一直向阳的人">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="一个一直向阳的人">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/elasticsearch_learning/img/ico.png">
  
  <link rel="stylesheet" type="text/css" href="/elasticsearch_learning/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

</head>
</html>
<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/elasticsearch_learning/" class="profilepic">
			<img src="https://kkewwei.github.io/elasticsearch_learning/img/myself.png" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/elasticsearch_learning/">jianguo</a></h1>
		</hgroup>
		
		<p class="header-subtitle">往事随风</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/elasticsearch_learning/">主页</a></li>
	        
				<li><a href="/elasticsearch_learning/tags/随笔/">随笔</a></li>
	        
				<li><a href="/elasticsearch_learning/categories">分类</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="mail" target="_blank" href="/elasticsearch_learning/kkewwei@163.com" title="mail"><i class="icon-mail"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="https://kkewwei.github.io/elasticsearch_learning/img/myself.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">jianguo</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>往事随风<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="mail" target="_blank" href="/elasticsearch_learning/kkewwei@163.com" title="mail"><i class="icon-mail"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 33.333333333333336%"><a href="/elasticsearch_learning/">主页</a></li>
		        
					<li style="width: 33.333333333333336%"><a href="/elasticsearch_learning/tags/随笔/">随笔</a></li>
		        
					<li style="width: 33.333333333333336%"><a href="/elasticsearch_learning/categories">分类</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-ES段合并源码分析" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/elasticsearch_learning/2019/10/17/ES段合并源码分析/">ES7.9.1段合并原理详解</a>
    </h1>
  

        
        <a href="/elasticsearch_learning/2019/10/17/ES段合并源码分析/" class="archive-article-date">
  	<time datetime="2019-10-17T11:02:48.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-10-17</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ES中在refresh、flush过程中, 都有可能触发段合并, 段合并是将小的段合并成大的段, merge过程有两个好处:</p>
<ol>
<li>加快查询速度</li>
<li>减少内存空间的占用<br>本文主要从ES7.3层面讲解是如何进行小的段文件合并成大的段文件的, 至于lucene层面的段合并, 之后也会整理一篇文档出来。</li>
</ol>
<h1 id="merge触发条件"><a href="#merge触发条件" class="headerlink" title="merge触发条件"></a>merge触发条件</h1><p>Merge首先会进入到IndexWriter的如下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">final void maybeMerge(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments) throws IOException &#123;</span><br><span class="line">    ensureOpen(false);</span><br><span class="line">    boolean newMergesFound = updatePendingMerges(mergePolicy, trigger, maxNumSegments);</span><br><span class="line">    mergeScheduler.merge(this, trigger, newMergesFound);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到参数trigger, 代表了所有可能触发merge的情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public enum MergeTrigger &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 由段flush触发merge</span><br><span class="line">   */</span><br><span class="line">  SEGMENT_FLUSH,</span><br><span class="line">  /**</span><br><span class="line">   * 可能因为一个commit触发full flush</span><br><span class="line">   */</span><br><span class="line">  FULL_FLUSH,</span><br><span class="line">  /**</span><br><span class="line">   * 用户通过接口手动触发merge</span><br><span class="line">   */</span><br><span class="line">  EXPLICIT,</span><br><span class="line">  /**</span><br><span class="line">   * 由前一个成功的merge触发的</span><br><span class="line">   */</span><br><span class="line">  MERGE_FINISHED,</span><br><span class="line">  /**</span><br><span class="line">   * IndexWriter类关闭而触发</span><br><span class="line">   */</span><br><span class="line">  CLOSING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="segments的挑选"><a href="#segments的挑选" class="headerlink" title="segments的挑选"></a>segments的挑选</h1><p>我们首先需要确定, 哪些端是需要合并的、是可以一起合并的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private synchronized boolean updatePendingMerges(MergePolicy mergePolicy, MergeTrigger trigger, int maxNumSegments)</span><br><span class="line">  throws IOException &#123;</span><br><span class="line">  ......</span><br><span class="line">  boolean newMergesFound = false;</span><br><span class="line">  final MergePolicy.MergeSpecification spec;</span><br><span class="line">  // 强制合并merge或者合并完之后再次进入</span><br><span class="line">  if (maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) &#123;</span><br><span class="line">   ......</span><br><span class="line">    // 是主动merge, 那么就去选择哪些segment需要合并</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    spec = mergePolicy.findMerges(trigger, segmentInfos, this);</span><br><span class="line">  &#125;</span><br><span class="line">  # 那么将改merge注册下。</span><br><span class="line">  newMergesFound = spec != null;</span><br><span class="line">  if (newMergesFound) &#123;</span><br><span class="line">    final int numMerges = spec.merges.size();</span><br><span class="line">    for(int i=0;i&lt;numMerges;i++) &#123;</span><br><span class="line">      // 把需要merge的段放进来</span><br><span class="line">      registerMerge(spec.merges.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newMergesFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里策略策略采用的:TieredMergePolicy, 根据名字我们就可以猜测, 每次挑选时都是按照每一阶层进行挑选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos infos, MergeContext mergeContext) throws IOException &#123;</span><br><span class="line">  // 该shard正在合并的段</span><br><span class="line">  final Set&lt;SegmentCommitInfo&gt; merging = mergeContext.getMergingSegments();</span><br><span class="line">  ......</span><br><span class="line">  // 按照semgnet大小排序，大的段拍起前面</span><br><span class="line">  List&lt;SegmentSizeAndDocs&gt; sortedInfos = getSortedBySegmentSize(infos, mergeContext);</span><br><span class="line">  Iterator&lt;SegmentSizeAndDocs&gt; iter = sortedInfos.iterator();</span><br><span class="line">   // 获取所有段总的删除比率</span><br><span class="line">  final double totalDelPct = 100 * (double) totalDelDocs / totalMaxDoc;</span><br><span class="line">  // 允许的删除比率</span><br><span class="line">  int allowedDelCount = (int) (deletesPctAllowed * totalMaxDoc / 100);</span><br><span class="line">  iter = sortedInfos.iterator();</span><br><span class="line">  // remove large segments from consideration under two conditions.</span><br><span class="line">  // 1&gt; Overall percent deleted docs relatively small and this segment is larger than 50% maxSegSize</span><br><span class="line">  // 2&gt; overall percent deleted docs large and this segment is large and has few deleted docs</span><br><span class="line">  // 所有的没有在合并的段都遍历</span><br><span class="line">  while (iter.hasNext()) &#123;</span><br><span class="line">    SegmentSizeAndDocs segSizeDocs = iter.next();</span><br><span class="line">    double segDelPct = 100 * (double) segSizeDocs.delCount / (double) segSizeDocs.maxDoc;</span><br><span class="line">    // 去掉大于2.5GB的段 &amp;&amp; 删除比率低的段</span><br><span class="line">    if (segSizeDocs.sizeInBytes &gt; maxMergedSegmentBytes / 2 &amp;&amp; (totalDelPct &lt;= deletesPctAllowed || segDelPct &lt;= deletesPctAllowed)) &#123;</span><br><span class="line">      iter.remove();</span><br><span class="line">      tooBigCount++; // Just for reporting purposes.</span><br><span class="line">      totIndexBytes -= segSizeDocs.sizeInBytes;</span><br><span class="line">      allowedDelCount -= segSizeDocs.delCount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  final int mergeFactor = (int) Math.min(maxMergeAtOnce, segsPerTier);</span><br><span class="line">  // Compute max allowed segments in the index</span><br><span class="line">  double allowedSegCount = 0;</span><br><span class="line">  // 计算allowedSegCount, 接下来会着重介绍。</span><br><span class="line">  return doFindMerges(sortedInfos, maxMergedSegmentBytes, mergeFactor, (int) allowedSegCount, allowedDelCount, MERGE_TYPE.NATURAL,</span><br><span class="line">      mergeContext, mergingBytes &gt;= maxMergedSegmentBytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要是为了过滤哪些segment是可以合并的:<br>1.首先过滤掉正在合并的段, 不能继续参与合并。<br>2.检查哪些段是不可以合并的, 需要同时满足一下两个条件:<br>+.段必须大于index.merge.policy.max_merged_segment&#x2F;2(默认2.5G)。<br>+.该段中需要删除的文档比率要高于index.merge.policy.deletes_pct_allowed(默认33%), 或者所有段的删除率高于该阈值(33%)。<br>那么剩余的segment都有可能参与合并, 也就是说, 只要所有段删除率&gt;33%, 或者该段删除率&gt;33%, 哪怕该段&gt;2.5G, 也是需要参与merge的。<br>3.获取allowedSegCount, 本shard允许的最大semgent个数, 也可以理想为合并前最少段的个数, 若段的个数达不到这个数, 就不能触发合并。该参数的计算很好的体现了分级合并的思想:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   // 每一级别合并的个数</span><br><span class="line">   final int mergeFactor = (int) Math.min(maxMergeAtOnce, segsPerTier);</span><br><span class="line">   // Compute max allowed segments in the index</span><br><span class="line">   // 每一级别合并的平均size</span><br><span class="line">   long levelSize = Math.max(minSegmentBytes, floorSegmentBytes);</span><br><span class="line">   long bytesLeft = totIndexBytes;</span><br><span class="line">   double allowedSegCount = 0;</span><br><span class="line">   // 一直在回归计算levelsize</span><br><span class="line">   while (true) &#123;</span><br><span class="line">     // 计算若在levelSize大小的level上面, 最大多少个segment个数</span><br><span class="line">     final double segCountLevel = bytesLeft / (double) levelSize;</span><br><span class="line">     // 若该level不超过规定的该阶segment个数</span><br><span class="line">     if (segCountLevel &lt; segsPerTier || levelSize == maxMergedSegmentBytes) &#123;</span><br><span class="line">       // 最终获取此值，允许合并的segment个数</span><br><span class="line">       allowedSegCount += Math.ceil(segCountLevel);</span><br><span class="line">       break;</span><br><span class="line">     &#125;</span><br><span class="line">     // 每次只增加该级别做多允许的semgent个数</span><br><span class="line">     allowedSegCount += segsPerTier;</span><br><span class="line">     // 理想情况下, 扣除该阶最大段个数, 剩余的size</span><br><span class="line">     bytesLeft -= segsPerTier * levelSize;</span><br><span class="line">     // 平均size增加一阶级, 比如从2M-&gt;20M</span><br><span class="line">     levelSize = Math.min(maxMergedSegmentBytes, levelSize * mergeFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我理解这种思想是每次合并时,都会找size尽量相同的semgent合并。这样限制了semgent多少个时, 才不用继续合并了。<br>4. 通过doFindMerges来确定真正需要合并的段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">private MergeSpecification doFindMerges(List&lt;SegmentSizeAndDocs&gt; sortedEligibleInfos,</span><br><span class="line">                                        final long maxMergedSegmentBytes,</span><br><span class="line">                                        final int mergeFactor, final int allowedSegCount,</span><br><span class="line">                                        final int allowedDelCount, final MERGE_TYPE mergeType,</span><br><span class="line">                                        MergeContext mergeContext,</span><br><span class="line">                                        boolean maxMergeIsRunning) throws IOException &#123;</span><br><span class="line">  MergeSpecification spec = null;</span><br><span class="line">  // The trigger point for total deleted documents in the index leads to a bunch of large segment</span><br><span class="line">  // merges at the same time. So only put one large merge in the list of merges per cycle. We&apos;ll pick up another</span><br><span class="line">  // merge next time around.  本轮是否已经选择了有大于5G的merge了, 若不控制, 可能会产生一堆大段合并, 引起IO问题</span><br><span class="line">  boolean haveOneLargeMerge = false;</span><br><span class="line">  // 一次选择多个merge</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    // 去掉已经被挑选出来合并的段</span><br><span class="line">    Iterator&lt;SegmentSizeAndDocs&gt; iter = sortedEligible.iterator();</span><br><span class="line">    while (iter.hasNext()) &#123;</span><br><span class="line">      SegmentSizeAndDocs segSizeDocs = iter.next();</span><br><span class="line">      if (toBeMerged.contains(segSizeDocs.segInfo)) &#123;</span><br><span class="line">        iter.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // OK we are over budget -- find best merge!</span><br><span class="line">    MergeScore bestScore = null;</span><br><span class="line">    List&lt;SegmentCommitInfo&gt; best = null;</span><br><span class="line">    boolean bestTooLarge = false;</span><br><span class="line">    long bestMergeBytes = 0;</span><br><span class="line">    // 每次固定第一位, 组成一个merge. 该merge只最大的那个段</span><br><span class="line">    for (int startIdx = 0; startIdx &lt; sortedEligible.size(); startIdx++) &#123;</span><br><span class="line">      // 该merge统计的所有segment合并后的size大小（若某个段删除比例大于33%，该段size并没有被包含进来）</span><br><span class="line">      实际5G是和该值比较的</span><br><span class="line">      long totAfterMergeBytes = 0;</span><br><span class="line">      // 以startIdx起点, 选择的一组段</span><br><span class="line">      final List&lt;SegmentCommitInfo&gt; candidate = new ArrayList&lt;&gt;();</span><br><span class="line">      // 合并时,尝试过合并后大于5G的机会</span><br><span class="line">      boolean hitTooLarge = false;</span><br><span class="line">      // 该merge中所有段的大小=totAfterMergeBytes+大于5G的段（删除比例大于33%）</span><br><span class="line">      long bytesThisMerge = 0;</span><br><span class="line">      // 然后逐次选择, 只要选中的个数小于阈值mergeFactor &amp; merge的总size&gt;5G</span><br><span class="line">      for (int idx = startIdx; idx &lt; sortedEligible.size() &amp;&amp; candidate.size() &lt; mergeFactor &amp;&amp; bytesThisMerge &lt; maxMergedSegmentBytes; idx++) &#123;</span><br><span class="line">        final SegmentSizeAndDocs segSizeDocs = sortedEligible.get(idx);</span><br><span class="line">        final long segBytes = segSizeDocs.sizeInBytes;</span><br><span class="line">         // 若合并的大于阈值5G</span><br><span class="line">        if (totAfterMergeBytes + segBytes &gt; maxMergedSegmentBytes) &#123;</span><br><span class="line">          // 触过顶</span><br><span class="line">          hitTooLarge = true;</span><br><span class="line">          // 主要是为了解决单个segment内大于5G、删除比率大于33%的段，这一个段就可以直接合并</span><br><span class="line">          if (candidate.size() == 0) &#123;</span><br><span class="line">            // We should never have something coming in that _cannot_ be merged, so handle singleton merges</span><br><span class="line">            candidate.add(segSizeDocs.segInfo);</span><br><span class="line">            bytesThisMerge += segBytes;</span><br><span class="line">          &#125;</span><br><span class="line">          //若第i个加进来, size太大了, 那么拿第i+1个段来尝试下</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        candidate.add(segSizeDocs.segInfo);</span><br><span class="line">        bytesThisMerge += segBytes; // 该merge合并后形成的segment的size大小</span><br><span class="line">        totAfterMergeBytes += segBytes;</span><br><span class="line">      &#125;</span><br><span class="line">      // 到此为止，找到了一批可以合并的segment</span><br><span class="line">      // If we didn&apos;t find a too-large merge and have a list of candidates</span><br><span class="line">      // whose length is less than the merge factor, it means we are reaching</span><br><span class="line">      // the tail of the list of segments and will only find smaller merges.</span><br><span class="line">      // Stop here. 若没有达到足够大的size, 并且合并的段不够多，那么我们已经遍历了所有的段也没有合适的，放弃继续查找了</span><br><span class="line">      if (bestScore != null &amp;&amp;  hitTooLarge == false &amp;&amp; candidate.size() &lt; mergeFactor) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      // 对该merge的这批segment进行打分,得分越低越好</span><br><span class="line">      final MergeScore score = score(candidate, hitTooLarge, segInfosSizes);</span><br><span class="line">      // (若是第一次选出 || 得分最低) &amp;&amp; (正在合并的所有段size&lt;5G || 当前merge没有达到阈值5G)</span><br><span class="line">      if ((bestScore == null || score.getScore() &lt; bestScore.getScore()) &amp;&amp; (!hitTooLarge || !maxMergeIsRunning)) &#123;</span><br><span class="line">        best = candidate;</span><br><span class="line">        bestScore = score;</span><br><span class="line">        bestTooLarge = hitTooLarge; // 是否超过阈值5G(有删除率&gt;33%)</span><br><span class="line">        bestMergeBytes = totAfterMergeBytes;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (best == null) &#123;</span><br><span class="line">      return spec;</span><br><span class="line">    &#125;</span><br><span class="line">    // The mergeType == FORCE_MERGE_DELETES behaves as the code does currently and can create a large number of</span><br><span class="line">    // concurrent big merges. If we make findForcedDeletesMerges behave as findForcedMerges and cycle through</span><br><span class="line">    // we should remove this.</span><br><span class="line">    // 若已经有大于5G的段待合并了，本轮又选择了大的段合并了，必须避免该情况。否则将会产生一大推大段合并。</span><br><span class="line">    if (haveOneLargeMerge == false || bestTooLarge == false || mergeType == MERGE_TYPE.FORCE_MERGE_DELETES) &#123;</span><br><span class="line">      haveOneLargeMerge |= bestTooLarge;</span><br><span class="line">      if (spec == null) &#123;</span><br><span class="line">        spec = new MergeSpecification();</span><br><span class="line">      &#125;</span><br><span class="line">      final OneMerge merge = new OneMerge(best);</span><br><span class="line">      spec.add(merge);</span><br><span class="line">      if (verbose(mergeContext)) &#123;</span><br><span class="line">        message(&quot;  add merge=&quot; + segString(mergeContext, merge.segments) + &quot; size=&quot; + String.format(Locale.ROOT, &quot;%.3f MB&quot;, bestMergeBytes / 1024. / 1024.) + &quot; score=&quot; + String.format(Locale.ROOT, &quot;%.3f&quot;, bestScore.getScore()) + &quot; &quot; + bestScore.getExplanation() + (bestTooLarge ? &quot; [max merge]&quot; : &quot;&quot;), mergeContext);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // whether we&apos;re going to return this list in the spec of not, we need to remove it from</span><br><span class="line">    // consideration on the next loop.</span><br><span class="line">    // 最终选择了一个合适的merge。</span><br><span class="line">    toBeMerged.addAll(best);</span><br><span class="line">  &#125;</span><br><span class="line">  // 再继续回归选择。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数选择合适的segment组成merge过程如下, while循环, 查找一个merge的过程如下:<br><img src="https://kkewwei.github.io/elasticsearch_learning/img/es_merge1.png" height="350" width="400"></p>
<ul>
<li>从第一个segment(size最大), 查找到一组segment,总size&lt;5G</li>
<li>从第二个segment(size最大), 查找到一组segment,总size&lt;5G</li>
<li>直到查找了末尾D组, 由于size&lt;5G &amp;&amp; count(segment) &lt; 10, 认为没有合适的,将丢弃改组。<br>每找到一组, 都会通过score()计算得分, 得分越低越好。 当前一轮仅仅会从这3组中选出一组出来进行merge。</li>
</ul>
<p>我们接下来看下score()是如何计算A、B、C组segment的得分的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">protected MergeScore score(List&lt;SegmentCommitInfo&gt; candidate, boolean hitTooLarge, Map&lt;SegmentCommitInfo, SegmentSizeAndDocs&gt; segmentsSizes) throws IOException &#123;</span><br><span class="line">  long totBeforeMergeBytes = 0;</span><br><span class="line">  long totAfterMergeBytes = 0;</span><br><span class="line">  long totAfterMergeBytesFloored = 0;</span><br><span class="line">  for(SegmentCommitInfo info : candidate) &#123;</span><br><span class="line">    final long segBytes = segmentsSizes.get(info).sizeInBytes;</span><br><span class="line">    totAfterMergeBytes += segBytes;</span><br><span class="line">    totAfterMergeBytesFloored += floorSize(segBytes);</span><br><span class="line">    totBeforeMergeBytes += info.sizeInBytes();</span><br><span class="line">  &#125;</span><br><span class="line">  // Roughly measure &quot;skew&quot; of the merge, i.e. how</span><br><span class="line">  // &quot;balanced&quot; the merge is (whether the segments are</span><br><span class="line">  // about the same size), which can range from</span><br><span class="line">  // 1.0/numSegsBeingMerged (good) to 1.0 (poor). Heavily</span><br><span class="line">  // lopsided merges (skew near 1.0) is no good; it means</span><br><span class="line">  // O(N^2) merge cost over time:</span><br><span class="line">  final double skew;</span><br><span class="line">  if (hitTooLarge) &#123;// 如果达到了5G上限</span><br><span class="line">    // Pretend the merge has perfect skew; skew doesn&apos;t</span><br><span class="line">    // matter in this case because this merge will not</span><br><span class="line">    // &quot;cascade&quot; and so it cannot lead to N^2 merge cost</span><br><span class="line">    // over time: 鼓励优先合并到最大值的, 此后就不在继续合并, 否则合并后的段还需要合并。</span><br><span class="line">    final int mergeFactor = (int) Math.min(maxMergeAtOnce, segsPerTier);</span><br><span class="line">     // 斜率是最低的, 可以认为是最均衡的</span><br><span class="line">    skew = 1.0/mergeFactor;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  // 若组合数=10个，skew = max(组合最大的端)/sum(组合总共的段)，1/10&lt;skew&lt;1 ，段大小差异越大，skew值越大</span><br><span class="line">    skew = ((double) floorSize(segmentsSizes.get(candidate.get(0)).sizeInBytes)) / totAfterMergeBytesFloored;</span><br><span class="line">  &#125;</span><br><span class="line">  // Strongly favor merges with less skew (smaller</span><br><span class="line">  // mergeScore is better):</span><br><span class="line">  double mergeScore = skew;</span><br><span class="line">  // Gently favor smaller merges over bigger ones.  We</span><br><span class="line">  // don&apos;t want to make this exponent too large else we</span><br><span class="line">  // can end up doing poor merges of small segments in</span><br><span class="line">  // order to avoid the large merges:</span><br><span class="line">  // 稍微倾斜合并小段，不想指数太大，否则将出现不会合并大段的情况</span><br><span class="line">  mergeScore *= Math.pow(totAfterMergeBytes, 0.05);</span><br><span class="line">  // Strongly favor merges that reclaim deletes:</span><br><span class="line">  final double nonDelRatio = ((double) totAfterMergeBytes)/totBeforeMergeBytes;</span><br><span class="line">  // 删除的越多，得分越小, 越是优先合并</span><br><span class="line">  mergeScore *= Math.pow(nonDelRatio, 2);</span><br><span class="line">  final double finalMergeScore = mergeScore;</span><br><span class="line">  return new MergeScore() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double getScore() &#123;</span><br><span class="line">      return finalMergeScore;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下, 针对每个merge打分, score越小越好:</p>
<ul>
<li>如果组合大小&lt;10个，说明是总大小到达5G才中断的，这样skew &#x3D; 1&#x2F;10,倾斜度最小，原因：不会再出现递归合并，可以认为算是最均匀分布的一种; 若组合数&#x3D;10个，skew &#x3D; max(组合最大的端)&#x2F;sum(组合总共的段)，1&#x2F;10&lt;skew&lt;1 ，段大小差异越大，skew值越大</li>
<li>skew &#x3D; skew*（抛出删除后总段的大小^0.05）:我们稍微倾向于合并小的端，原因：若源源不断的产生小段，我们则会忽略大段的合并。稍微的含义:在5G的大小内，后面系数&lt;3。</li>
<li>mergescore &#x3D; skew *[不需要删除的文档&#x2F;(需要删除的文档+不需要删除的文档)]^2：说明merge的段中包含越多的被删除的段，score越小。</li>
</ul>
<h1 id="merge过程"><a href="#merge过程" class="headerlink" title="merge过程"></a>merge过程</h1><p>merge过程将进入ConcurrentMergeScheduler.merge()中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException &#123;</span><br><span class="line">  // 遍历直到将所有需要合并的merge全部进行了才退出</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    OneMerge merge = writer.getNextMerge();</span><br><span class="line">    if (merge == null) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean success = false;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 新产生一个线程去处理这个merge</span><br><span class="line">      final MergeThread newMergeThread = getMergeThread(writer, merge);</span><br><span class="line">      mergeThreads.add(newMergeThread);</span><br><span class="line">      // 更新全局维护的段合并速度（看是否有合并慢的段）,同时初始化新创建的这个的merge速度</span><br><span class="line">      updateIOThrottle(newMergeThread.merge, newMergeThread.rateLimiter);</span><br><span class="line">      // merge线程开始进行工作</span><br><span class="line">      newMergeThread.start();</span><br><span class="line">      // 更新全局维持的段合并速度，来更新存在的每个的段合并速度</span><br><span class="line">      updateMergeThreads();</span><br><span class="line">      success = true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (!success) &#123;</span><br><span class="line">        writer.mergeFinish(merge);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并过程比较简单, 获取所有的merge并循环:</p>
<ol>
<li>通过updateIOThrottle更新全局维护的合并速度, 并初始化当前合并速度。</li>
<li>启动合并线程。</li>
<li>通过updateMergeThreads更新所有段的合并速度。<br>就这样不断循环, 产生新的合并线程。</li>
</ol>
<h2 id="更新全局维护的合并速度"><a href="#更新全局维护的合并速度" class="headerlink" title="更新全局维护的合并速度"></a>更新全局维护的合并速度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private synchronized void updateIOThrottle(OneMerge newMerge, MergeRateLimiter rateLimiter) throws IOException &#123;</span><br><span class="line">   // 自动限流关闭了</span><br><span class="line">  if (doAutoIOThrottle == false) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  double mergeMB = bytesToMB(newMerge.estimatedMergeBytes);// 待合并的merge大小</span><br><span class="line">  // 如果待合并的merge小于50M的话，不会对IO产生太大影响, 忽略。</span><br><span class="line">  if (mergeMB &lt; MIN_BIG_MERGE_MB) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  long now = System.nanoTime();</span><br><span class="line">  // 如果发现有相似的merge，则说明当前level的merge落后了。</span><br><span class="line">  boolean newBacklog = isBacklog(now, newMerge);</span><br><span class="line">  // 检查存在的合并是否被阻塞了</span><br><span class="line">  boolean curBacklog = false;</span><br><span class="line">   // 新的没有阻塞</span><br><span class="line">  if (newBacklog == false) &#123;</span><br><span class="line">    // 若正在merge的线程个数超过maxThreadCount限制</span><br><span class="line">    if (mergeThreads.size() &gt; maxThreadCount) &#123;</span><br><span class="line">      curBacklog = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Now see if any still-running merges are backlog&apos;d:</span><br><span class="line">      // 存在的线程中有相同level的merge</span><br><span class="line">      for (MergeThread mergeThread : mergeThreads) &#123;</span><br><span class="line">        if (isBacklog(now, mergeThread.merge)) &#123;</span><br><span class="line">          curBacklog = true;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  double curMBPerSec = targetMBPerSec; // 初始值为20M</span><br><span class="line">  // 若新的是被阻塞了,那么整体提速20%, 加快合并速度</span><br><span class="line">  if (newBacklog) &#123;</span><br><span class="line">    // 合并速度提速20%</span><br><span class="line">    targetMBPerSec *= 1.20;</span><br><span class="line">    // 5m-1024m之间变动</span><br><span class="line">    if (targetMBPerSec &gt; MAX_MERGE_MB_PER_SEC) &#123;</span><br><span class="line">      targetMBPerSec = MAX_MERGE_MB_PER_SEC;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (curBacklog) &#123;</span><br><span class="line">   // 若旧的被阻塞了，则不变</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  // 若新旧合并都没有问题, 那么没必要维持该合并速度</span><br><span class="line">    // We are not falling behind: decrease IO throttle by 10%</span><br><span class="line">    targetMBPerSec /= 1.10; // 那么降速10%</span><br><span class="line">    if (targetMBPerSec &lt; MIN_MERGE_MB_PER_SEC) &#123;</span><br><span class="line">      targetMBPerSec = MIN_MERGE_MB_PER_SEC;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  double rate;</span><br><span class="line">  if (newMerge.maxNumSegments != -1) &#123;</span><br><span class="line">    rate = forceMergeMBPerSec;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    rate = targetMBPerSec;</span><br><span class="line">  &#125;</span><br><span class="line">  rateLimiter.setMBPerSec(rate);</span><br><span class="line">  targetMBPerSecChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要做了如下事情:</p>
<ol>
<li>若当前merge的size &lt; 50MB, 将不对全局合并速度产生影响, 后面我们也可以看到size &lt; 50MB的merge就没有限速。</li>
<li>首先检查已经存在的merge size和即将合并的线程size是否在同一个level, 若有的话, 说明新的merge合并速度慢了。更新全局合并速度, 提速20%</li>
<li>检查已经存在的merges, 该部分合并慢了有两种可能性:</li>
</ol>
<ul>
<li>当前正在合并的线程超过阈值:maxThreadCount。</li>
<li>正在合并的merges内部是否有相同level的merge。<br>若当前合并慢了, 不做任何处理。若不慢的话, 全局合并速度下降10%。</li>
</ul>
<h2 id="启动合并线程"><a href="#启动合并线程" class="headerlink" title="启动合并线程"></a>启动合并线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        // merge线程才会真正去调用beforeMerge，aftermerge</span><br><span class="line">        doMerge(writer, merge);</span><br><span class="line">        // Let CMS run new merges if necessary:</span><br><span class="line">        try &#123; // 循环检查是否还有merge需要进行</span><br><span class="line">          merge(writer, MergeTrigger.MERGE_FINISHED, true);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;  finally &#123;</span><br><span class="line">        synchronized(ConcurrentMergeScheduler.this) &#123;</span><br><span class="line">          removeMergeThread();</span><br><span class="line">          updateMergeThreads();</span><br><span class="line">          // In case we had stalled indexing, we can now wake up</span><br><span class="line">          // and possibly unstall:</span><br><span class="line">          ConcurrentMergeScheduler.this.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要做了如下事情:</p>
<ul>
<li>通过调用doMerge()进行真正合并过程。</li>
<li>调用merge()进行循环第二章节的操作。</li>
<li>调用updateMergeThreads()调整当前正在进行的merge速度。<h3 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h3>merge线程真正进行段合并在时ElasticsearchConcurrentMergeScheduler.doMerge()里面完成的:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void doMerge(IndexWriter writer, MergePolicy.OneMerge merge) throws IOException &#123; // 开始合并</span><br><span class="line">      int totalNumDocs = merge.totalNumDocs();</span><br><span class="line">      OnGoingMerge onGoingMerge = new OnGoingMerge(merge);</span><br><span class="line">      onGoingMerges.add(onGoingMerge);</span><br><span class="line">      try &#123;</span><br><span class="line">          beforeMerge(onGoingMerge); // 进行合并前的检查</span><br><span class="line">          super.doMerge(writer, merge); // 真正调用lucene进行合并</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          onGoingMerges.remove(onGoingMerge);</span><br><span class="line">          afterMerge(onGoingMerge); // 去调用取消限速等</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>合并过程分为3个阶段:</p>
<ol>
<li>调用beforeMerge, 检查当前merge线程是否超过阈值maxMergeCount, 若超过了, 那么将对该shard的所有写入都限速为0。 我们经常看到<code>now throttling indexing: numMergesInFlight=</code>类似的提示, 就是这里打印的。</li>
<li>调用super.doMerge()进行lucene层面merge。</li>
<li>调用afterMerge, 查看是否需要解除该shard的写入限制。</li>
</ol>
<h2 id="更新所有段合并速度"><a href="#更新所有段合并速度" class="headerlink" title="更新所有段合并速度"></a>更新所有段合并速度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized void updateMergeThreads() &#123;</span><br><span class="line"></span><br><span class="line">  final List&lt;MergeThread&gt; activeMerges = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  int threadIdx = 0;</span><br><span class="line">  while (threadIdx &lt; mergeThreads.size()) &#123;</span><br><span class="line">    final MergeThread mergeThread = mergeThreads.get(threadIdx);</span><br><span class="line">    if (!mergeThread.isAlive()) &#123;</span><br><span class="line">      // Prune any dead threads</span><br><span class="line">      mergeThreads.remove(threadIdx);</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    activeMerges.add(mergeThread);</span><br><span class="line">    threadIdx++;</span><br><span class="line">  &#125; // 更新维持的merge线程情况，去掉已经完成的</span><br><span class="line"></span><br><span class="line">  // Sort the merge threads, largest first:</span><br><span class="line">  // segment最大的放最前面</span><br><span class="line">  CollectionUtil.timSort(activeMerges);</span><br><span class="line">  final int activeMergeCount = activeMerges.size();</span><br><span class="line">  int bigMergeCount = 0;</span><br><span class="line">  for (threadIdx=activeMergeCount-1;threadIdx&gt;=0;threadIdx--) &#123;</span><br><span class="line">    MergeThread mergeThread = activeMerges.get(threadIdx);</span><br><span class="line">    //只是统计大于50的段合并线程个数</span><br><span class="line">    if (mergeThread.merge.estimatedMergeBytes &gt; MIN_BIG_MERGE_MB*1024*1024) &#123;</span><br><span class="line">      bigMergeCount = 1+threadIdx;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (threadIdx=0;threadIdx&lt;activeMergeCount;threadIdx++) &#123; // 遍历全部的端合并线程</span><br><span class="line">    MergeThread mergeThread = activeMerges.get(threadIdx);</span><br><span class="line">    OneMerge merge = mergeThread.merge;</span><br><span class="line">    // pause the thread if maxThreadCount is smaller than the number of merge threads.</span><br><span class="line">    // 若最大的超过限制个数的最大的那个几个，直接暂停速度。小于50M的不限速，别的调整规定速度。</span><br><span class="line">    final boolean doPause = threadIdx &lt; bigMergeCount - maxThreadCount;</span><br><span class="line">    double newMBPerSec;</span><br><span class="line">    if (doPause) &#123; // 大于的直接为0</span><br><span class="line">      newMBPerSec = 0.0;</span><br><span class="line">      // 是强制合并的速度</span><br><span class="line">    &#125; else if (merge.maxNumSegments != -1) &#123;</span><br><span class="line">      newMBPerSec = forceMergeMBPerSec;</span><br><span class="line">    &#125; else if (doAutoIOThrottle == false) &#123; //</span><br><span class="line">      newMBPerSec = Double.POSITIVE_INFINITY;</span><br><span class="line">       // 若端的大小小于50M，则没有限制</span><br><span class="line">    &#125; else if (merge.estimatedMergeBytes &lt; MIN_BIG_MERGE_MB*1024*1024) &#123;</span><br><span class="line">      // Don&apos;t rate limit small merges:</span><br><span class="line">      newMBPerSec = Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    // 将全局的段合并速度用来更新本身的段合并速度</span><br><span class="line">      newMBPerSec = targetMBPerSec;</span><br><span class="line">    &#125;</span><br><span class="line">    MergeRateLimiter rateLimiter = mergeThread.rateLimiter;</span><br><span class="line">    double curMBPerSec = rateLimiter.getMBPerSec();</span><br><span class="line">    // 更新本身的段合并速度</span><br><span class="line">    rateLimiter.setMBPerSec(newMBPerSec);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新所有存在的merge合并速度逻辑如下:</p>
<ol>
<li>删除已经完成的merge线程, 并将存活的merge按照size从大到小进行排序,放入activeMerges中。</li>
<li>统计size&gt;50MB的合并线程。</li>
<li>遍历activeMerges:</li>
</ol>
<ul>
<li>对于超过规定阈值maxThreadCount的大于50MB的merge线程进行限速, 合并速度直接降为0。注意是从最大的size的merge开始遍历的。</li>
<li>若设置了不限速, 则取消限速。</li>
<li>若合并线程的size&lt;50MB, 不进行限速。</li>
<li>若合并的merge大于&gt;50, 同时在规定的阈值maxThreadCount之内的线程, 调整合并速度为全局速度。</li>
</ul>
<p>有两个参数比较重要, 需要注意下: maxMergeCount和maxThreadCount:</p>
<ol>
<li>maxMergeCount主要是从ES写入的方面限制的, 应用在merge线程真正进行merge前, 检查当前正在合并的线程个数是否超过该阈值, 若超过了的话, 该shard上所有写入都将被禁止。</li>
<li>maxThreadCount主要是从限制merge合并速度的方向限制的, 用在两个地方:</li>
</ol>
<ul>
<li>确定当前正在进行的merge是否超过该阈值, 超过后, 就认为当前已存在的merge合并速度慢了,仅仅会打个日志(若没超过,且正在合并的merge没有相同level的mege, 就会降10%合并速度)</li>
<li>在更新全局合并速度时, 若大于50MB的合并线程数大于该阈值, 超过的merge都会被直接暂停合并。</li>
<li>若合并线程的merge小于50M，将不受限速的影响。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文着重从merge调度层面讲解的, 比如如何选择segment, 如何动态调整merge速度的。至于lucene层面的合并, 将在之后的文档中详细介绍。从分析角度看, merge还是有些问题的, 比如只考虑单个shard的合并速度, 却没有在node层面进行限速。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">ES, Semgent Merge</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/elasticsearch_learning/categories/Elasticsearch//" class="article-tag-list-link color4">Elasticsearch</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/elasticsearch_learning/2019/10/17/ES段合并源码分析/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Lucene8-2-0底层架构-ByteBlockPool结构分析" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/elasticsearch_learning/2019/10/06/Lucene8-2-0底层架构-ByteBlockPool结构分析/">Lucene8.2.0底层架构-ByteBlockPool结构分析</a>
    </h1>
  

        
        <a href="/elasticsearch_learning/2019/10/06/Lucene8-2-0底层架构-ByteBlockPool结构分析/" class="archive-article-date">
  	<time datetime="2019-10-06T08:04:05.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-10-06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Lucene在建立倒排索引结构时, 需要存储大量的byte数组, 并不能固定需要在一个数组中存放多少byte。数组不能扩展的特性并不能很好的解决动态扩容的问题, Lucene自己开发了类ByteBlockPool来满足这一特性。针对int类型开发了IntBlockPool, 两者原理相同, 本文就以ByteBlockPool存储细节来展开介绍。</p>
<h1 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h1><p>先看下相关属性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> // 真正存放byte的地方, 还是可以扩容的。</span><br><span class="line"> public byte[][] buffers = new byte[10][];</span><br><span class="line"> //指向二元buffers的第一元指针, 当前正在向第几个byte[]存放数据</span><br><span class="line"> private int bufferUpto = -1;</span><br><span class="line">//当前正在写入的byte[]内的相对偏移量，就是buffer内可分配的起始位置。</span><br><span class="line"> public int byteUpto = BYTE_BLOCK_SIZE;</span><br><span class="line"> //当前块buffer</span><br><span class="line"> public byte[] buffer;</span><br><span class="line">// buffer在所有buffers的位置（当前buffer在全局的偏移量），(bufferUpto -1)*BYTE_BLOCK_SIZE</span><br><span class="line"> public int byteOffset = -BYTE_BLOCK_SIZE;</span><br><span class="line"> // 当使用完当前buffer后, 会再次申请一个byte[]来存放byte。每次申请一个byte[], 都对应了一个级别, 每个级别可以申请的内存大小都是固定的。NEXT_LEVEL_ARRAY定义当前级别的下一个级别是第几级, LEVEL_SIZE_ARRAY对应了每个级别可以申请的byte[]大小。最多有9级别, 当超过第9级别后, 后面再申请的话, 只能是第9级。这里使用了一个小技巧来实现这个操作, NEXT_LEVEL_ARRAY[8]=9,表示第8级别后面是第9级, NEXT_LEVEL_ARRAY[9]=9表示第9级后面还是第9级。</span><br><span class="line"> public final static int[] NEXT_LEVEL_ARRAY = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 9&#125;;</span><br><span class="line"> public final static int[] LEVEL_SIZE_ARRAY = &#123;5, 14, 20, 30, 40, 40, 80, 80, 120, 200&#125;;</span><br><span class="line"> // 定义了最开始的分配byte[]的级别</span><br><span class="line"> public final static int FIRST_LEVEL_SIZE = LEVEL_SIZE_ARRAY[0];</span><br></pre></td></tr></table></figure>

<p>ByteBlockPool使用二进制buffers来真正存储数据, 当需要扩容时候, 产生新的数组来存储byte。</p>
<h1 id="产生buffer"><a href="#产生buffer" class="headerlink" title="产生buffer"></a>产生buffer</h1><p>当前<code>buffer</code>不足以存放byte时, 就会产生新的32kb大小的byte[]来存放数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// buffer已经不足以新的申请需求, 那么就产生新的buffer来存放, 一次申请不能超过32kb大小空间</span><br><span class="line">public void nextBuffer() &#123;</span><br><span class="line">   // buffers中已存满buffer了, 需要扩容</span><br><span class="line">   if (1+bufferUpto == buffers.length) &#123;</span><br><span class="line">     byte[][] newBuffers = new byte[ArrayUtil.oversize(buffers.length+1,</span><br><span class="line">                                                       NUM_BYTES_OBJECT_REF)][];</span><br><span class="line">     // 只是拷贝了数组引用，并没有copy数组, 这里体现了ByteBlockPool的优势</span><br><span class="line">     System.arraycopy(buffers, 0, newBuffers, 0, buffers.length);</span><br><span class="line">     buffers = newBuffers;</span><br><span class="line">   &#125;</span><br><span class="line">   //产生一个新的buffer, 大小为32kb, 供slice来分配数据</span><br><span class="line">   buffer = buffers[1+bufferUpto] = allocator.getByteBlock();</span><br><span class="line">   bufferUpto++;//buffers写入位置+1</span><br><span class="line"></span><br><span class="line">   byteUpto = 0;//buffer写入位置</span><br><span class="line">   byteOffset += BYTE_BLOCK_SIZE;//指针位置初始化</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>产生新buffer过程, 就是对ByteBlockPool扩容的过程, 相对于二进制或者List扩容, ByteBlockPool的优势在于不对数据进行移动, 移动的仅仅是数组指针。 扩容时产生一个32k的byte数组。ByteBlockPool仅仅管理这些byte[]的指针。</p>
<h1 id="从buffer中产生slice"><a href="#从buffer中产生slice" class="headerlink" title="从buffer中产生slice"></a>从buffer中产生slice</h1><p>ByteBlockPool申请一个空闲的32k的数组buffer。每次写入byte时, 首先会从这个buffer中申请一块区域存放byte, 这块区域就称为一个slice。 我们看下ByteBlockPool是如何管理从buffer中申请slice的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 从当前buffer中申请一个size大小的slice</span><br><span class="line">public int newSlice(final int size) &#123;</span><br><span class="line">   // 当前buffer剩余可用空间装不下size了, 那么我们就需要产生一个新的buffer了</span><br><span class="line">  if (byteUpto &gt; BYTE_BLOCK_SIZE-size)</span><br><span class="line">    nextBuffer();</span><br><span class="line">  // 此时能保证当前buffer一定可以存的下size了</span><br><span class="line">  final int upto = byteUpto;</span><br><span class="line">  byteUpto += size;</span><br><span class="line">  buffer[byteUpto-1] = 16;//赋值为16 调用时 会从byteUpto开始写入，当遇到buffer[pos]位置不为0 时，会调用allocSlice方法 通过 16&amp;15得到当前NEXT_LEVEL_ARRAY中level</span><br><span class="line">  return upto; //申请的slice的相对起始位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新申请的slice的大小是FIRST_LEVEL_SIZE:5, 该函数主要做了如下事情:<br>1.检查当前buffer剩余空间是否能满足size大小的slice申请, 若不满足, 另外创建一个新的buffer作为当前工作buffer。<br>2.在当前buffer中申请新的slice, 将该slice最后一位存放16. 代表下一级申请slice的级别大小:16&amp;15&#x3D;1。<br>申请过程如下:<br><img src="https://kkewwei.github.io/elasticsearch_learning/img/lucene_bytebuffer.png" height="200" width="600"><br>可以看到, 若buffer剩余空间不足以存储, 会去申请新的buffer。</p>
<h1 id="扩容现存的slice"><a href="#扩容现存的slice" class="headerlink" title="扩容现存的slice"></a>扩容现存的slice</h1><p>ByteBlockPool主要解决的问题是数组动态扩容的问题, 我们不确定未来还有多少字符串需要继续写入, 我们首次申请的slice区域很可能就不够用, 而allocSlice解决的就是对当前slice扩容的问题。扩容前我们首先回答如下几个问题:<br>什么时候需要扩容? 扩容多大? 每个slice存储结尾都会存放下一个申请内存的slice, 当即将写入的位置不为0, 则说明说明当前byte代表着slice已经存满, 该byte代表着扩容slice申请数组的一个级别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// slice代表当前buffer, upto代表slice结束位置, slice[upto]存放的是下一级别</span><br><span class="line">public int allocSlice(final byte[] slice, final int upto) &#123;</span><br><span class="line">    // 确定下一级别</span><br><span class="line">    final int level = slice[upto] &amp; 15;</span><br><span class="line">    final int newLevel = NEXT_LEVEL_ARRAY[level];</span><br><span class="line">    // 下一级别申请的大小</span><br><span class="line">    final int newSize = LEVEL_SIZE_ARRAY[newLevel];</span><br><span class="line"></span><br><span class="line">    // 当前buffer是否还够下一级别的byte[]的申请</span><br><span class="line">    if (byteUpto &gt; BYTE_BLOCK_SIZE-newSize) &#123;</span><br><span class="line">      nextBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">     // 当前块的起始位置</span><br><span class="line">    final int newUpto = byteUpto;</span><br><span class="line">     // upto的在整个buffers的绝对位置</span><br><span class="line">    final int offset = newUpto + byteOffset;</span><br><span class="line">    // 目前buffer内新的可写入位置</span><br><span class="line">    byteUpto += newSize;</span><br><span class="line">    // 从当前级别空余3位出来存储当前slice扩容下一级别的起始位置</span><br><span class="line">    // 第一步, 先空出</span><br><span class="line">    buffer[newUpto] = slice[upto-3];</span><br><span class="line">    buffer[newUpto+1] = slice[upto-2];</span><br><span class="line">    buffer[newUpto+2] = slice[upto-1];</span><br><span class="line">     // 空出来的3位连同级别位存放位置</span><br><span class="line">    // Write forwarding address at end of last slice:</span><br><span class="line">    slice[upto-3] = (byte) (offset &gt;&gt;&gt; 24);</span><br><span class="line">    slice[upto-2] = (byte) (offset &gt;&gt;&gt; 16);</span><br><span class="line">    slice[upto-1] = (byte) (offset &gt;&gt;&gt; 8);</span><br><span class="line">    slice[upto] = (byte) offset;</span><br><span class="line">    // 在新扩容的slice结尾填写下一级别</span><br><span class="line">    // Write new level:</span><br><span class="line">    buffer[byteUpto-1] = (byte) (16|newLevel);</span><br><span class="line">    return newUpto+3;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>主要过程用图像表示如下:<br><img src="https://kkewwei.github.io/elasticsearch_learning/img/lucene_bytebuffer1.png" height="250" width="600"><br>其中address是在整个buffers中的绝对位置。 一个buffer可以产生不同的slice, 每个slice不需要连续, 相当于一个链串结构。 slice扩容分为9级, 达到9级后新申请的内存大小都按照第9级别来分配。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ByteBlockPool通过管理字符串二维数组方式实现动态扩容, 而且扩容成本也不高。lucene中在字符串存储上使用了较多较为巧妙的方法, 正是这些巧妙方法, 使得lucene有着比较优秀的性能。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">Lucene、ByteBlockPool</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/elasticsearch_learning/categories/Lucene//" class="article-tag-list-link color2">Lucene</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/elasticsearch_learning/2019/10/06/Lucene8-2-0底层架构-ByteBlockPool结构分析/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-关于linux-信号量的学习" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/elasticsearch_learning/2019/09/01/关于linux-信号量的学习/">关于linux 信号量的学习</a>
    </h1>
  

        
        <a href="/elasticsearch_learning/2019/09/01/关于linux-信号量的学习/" class="archive-article-date">
  	<time datetime="2019-09-01T11:29:45.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-09-01</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们可能经常会使用kill -9 pid 来kill某个进程, 其实-9就是某一种信号量, 今天我们将简单讲解下信号量的使用。 linux中信号就是软件中断, 它提供了一种处理异步时间的方法: 终端用户键入中断键, 则会通过信号机构停止一个程序。产生信号的事件对于进程而言则是随机出现的。 进程表態只测试一个变量来判别是否发生了一个信号, 而是必须告诉内核”在此信号发生时, 请执行以下操作”, 可以要求系统在某个信号按照以下三种的其中一种方式操作:<br>(1) 忽略信号, 大多数信号都可使用这种方式处理, 但是有两只中信号决不能被忽略, 它们是SIGKILL和SIGSTOP。这两种信号不能被忽略的原因是: 它们向超级用户提供一种使进程终止或者停止的可靠方法。另外, 如果忽略某种由硬件异常产生的信号(例如非法存储访问或者除以0), 则金恒的行为是未定义的。<br>(2) 捕获信号, 为了做到这一点要通知内核在某种信号发生时, 调用一个用户函数。在用户函数中, 可执行用户希望对这种事件进行的处理, 例如, 若编写一个命令解释器, 当用户用键盘产生中断信号后, 很可能希望用户返回到程序的主循环, 终止系统正在为用户执行的命令。 若果捕获到SIGCHILD信号, 则表示子进程已经终止, 所以此信号的捕获可以调用waitpid以取得该子进程的进程ID已经它的最终状态。 又例如, 如果进程创建了临时文件, 那么可能要为SIGTERM信号编写一个信号捕获函数以清理临时文件(kill命令传送的信号默认信号时终止信号)。<br>(3) 执行系统默认动作。对于大部分信号的系统默认动作是终止该进程。<br><img src="https://kkewwei.github.io/elasticsearch_learning/img/signal_1.png" height="450" width="500"><br><img src="https://kkewwei.github.io/elasticsearch_learning/img/signal_2.png" height="250" width="480"><br>想了解每个信号的含义, 可以参考《Unix环境高级编程》一书, 每种信号可以由一个数字表示, 这里罗列一些常见的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Some of the more commonly used signals:</span><br><span class="line">1       HUP (hang up)</span><br><span class="line">2       INT (interrupt)</span><br><span class="line">3       QUIT (quit)</span><br><span class="line">6       ABRT (abort, 调用abort时触发)</span><br><span class="line">9       KILL (non-catchable, non-ignorable kill)</span><br><span class="line">14      ALRM (alarm clock)</span><br><span class="line">15      TERM (software termination signal)</span><br><span class="line">30      SIGUSR1 (user defined signal 1)</span><br><span class="line">31      SIGUSR2 (user defined signal 2)</span><br></pre></td></tr></table></figure>

<p>在系统默认动作列中, “终止w&#x2F;core”表示在进程当前工作目录的core文件中复制了该进程的存储图像(该文件名为core)。 在以下条件下不产生core文件:<br>(a) 程是设置-用户-ID, 而且当前用户并非程序文件的所有者<br>(b) 进程是设置-组-ID ,而且当前用户并非该程序文件的组所有者<br>(c)用户没有写当前工作目录的许可权<br>(d) 文件太大。我们经常使用<code>ulimit -c unlimited</code>设置core文件大小。</p>
<h1 id="sinal函数和sigaction函数"><a href="#sinal函数和sigaction函数" class="headerlink" title="sinal函数和sigaction函数"></a>sinal函数和sigaction函数</h1><p>我们想自定义某些信号的处理函数, 那就需要用到sinal函数和sigaction函数, 还有别的常见的修改指定信号相关联操作的函数, 再次不罗列了。<br>我们直接使用示例进行说明吧:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void *thread_function(void *arg) &#123;</span><br><span class="line">    printf(&quot;My PID is %ld\n&quot;, (long)pthread_self());</span><br><span class="line">    signal(SIGUSR1, sig_usr);</span><br><span class="line">    // 读数被卡</span><br><span class="line">    char buf[511];</span><br><span class="line">    read(STDIN_FILENO, buf, 511);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(void) &#123;</span><br><span class="line">    pthread_t mythread;</span><br><span class="line">      if (pthread_create( &amp;mythread, NULL, thread_function, NULL) ) &#123;</span><br><span class="line">        printf(&quot;error creating thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(1);</span><br><span class="line">    // kill子线程, 向子线程发送SIGUSR1信号</span><br><span class="line">    pthread_kill(mythread, SIGUSR1);</span><br><span class="line">    printf(&quot;My PID is %d\n&quot;, getpid());</span><br><span class="line">    for(;;) &#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 信号处理函数</span><br><span class="line">static void sig_usr(int signum) &#123;</span><br><span class="line">    if(signum == SIGUSR1) &#123;</span><br><span class="line">        printf(&quot;SIGUSR1 received\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(signum == SIGUSR2) &#123;</span><br><span class="line">        printf(&quot;SIGUSR2 received\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;signal %d received\n&quot;, signum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main1(void) &#123;</span><br><span class="line">    char buf[512];</span><br><span class="line">    int  n;</span><br><span class="line"></span><br><span class="line">    struct sigaction sa_usr;</span><br><span class="line">    sa_usr.sa_flags = 0;</span><br><span class="line">    sa_usr.sa_handler = sig_usr;</span><br><span class="line">    //自定义信号处理函数, sa_usr里面存放了信号处理函数</span><br><span class="line">    sigaction(SIGUSR1, &amp;sa_usr, NULL);</span><br><span class="line">    sigaction(SIGHUP, &amp;sa_usr, NULL);</span><br><span class="line">    sigaction(SIGQUIT, &amp;sa_usr, NULL);</span><br><span class="line">    //自定义信号处理函数, 信号处理函数可以直接放在外面</span><br><span class="line">    signal(SIGUSR2, sig_usr);</span><br><span class="line">    printf(&quot;My PID is %d\n&quot;, getpid());</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        // 读数据被阻塞</span><br><span class="line">        if((n = read(STDIN_FILENO, buf, 511)) == -1) &#123;</span><br><span class="line">            // 返回值代表read被中断</span><br><span class="line">            if(errno == EINTR) &#123;</span><br><span class="line">                printf(&quot;read is interrupted by signal\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            buf[n] = &apos;\0&apos;;</span><br><span class="line">            printf(&quot;%d bytes read: %s\n&quot;, n, buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>针对main1()运行时, 将会打印当前pid。 然后我们可以在终端环境下输入<code>kill -SIGUSR1 pid</code> <code>kill -SIGUSR1 pid</code>, 可以看到进程接收到信号量后, 交由自定义函数处理的。</li>
<li>针对main()运行时, 我们可以通过<code>pthread_kill</code>显示对某个线程发送信号量。<br>sinal函数和sigaction函数使用都比较简单, sigaction会代替早期实现的sinal。</li>
</ol>
<p>参考:<br>《Unix环境高级编程》第十章 信 号</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/elasticsearch_learning/categories/Linux网络编程//" class="article-tag-list-link color5">Linux网络编程</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/elasticsearch_learning/2019/09/01/关于linux-信号量的学习/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Linux网络通信管道的关闭分析" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/elasticsearch_learning/2019/09/01/Linux网络通信管道的关闭分析/">Linux网络通信管道的关闭分析</a>
    </h1>
  

        
        <a href="/elasticsearch_learning/2019/09/01/Linux网络通信管道的关闭分析/" class="archive-article-date">
  	<time datetime="2019-09-01T11:27:30.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-09-01</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">Linux, close</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/elasticsearch_learning/categories/Linux网络编程//" class="article-tag-list-link color5">Linux网络编程</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/elasticsearch_learning/2019/09/01/Linux网络通信管道的关闭分析/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-ES原理-下线节点时分片并发rebalance的思考" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/elasticsearch_learning/2019/06/16/ES原理-下线节点时分片并发rebalance的思考/">ES原理-下线节点时分片并发rebalance的思考</a>
    </h1>
  

        
        <a href="/elasticsearch_learning/2019/06/16/ES原理-下线节点时分片并发rebalance的思考/" class="archive-article-date">
  	<time datetime="2019-06-16T14:29:49.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-06-16</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><h2 id="现象1"><a href="#现象1" class="headerlink" title="现象1"></a>现象1</h2><p>最近在下线ES5.6.8集群节点时候, 发现了一个很奇怪的现象, 我先把cluster参数给贴出来看下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;transient&quot;: &#123;</span><br><span class="line">        &quot;cluster&quot;: &#123;</span><br><span class="line">         &quot;routing&quot;: &#123;</span><br><span class="line">            &quot;rebalance&quot;: &#123;</span><br><span class="line">               &quot;enable&quot;: &quot;all&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;allocation&quot;: &#123;</span><br><span class="line">               &quot;allow_rebalance&quot;: &quot;always&quot;,</span><br><span class="line">               &quot;cluster_concurrent_rebalance&quot;: &quot;1&quot;,</span><br><span class="line">               &quot;node_concurrent_recoveries&quot;: &quot;1&quot;,</span><br><span class="line">               &quot;node_initial_primaries_recoveries&quot;: &quot;1&quot;,</span><br><span class="line">               &quot;enable&quot;: &quot;all&quot;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我通过如下命令下线4个节点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;transient&quot;: &#123;</span><br><span class="line">         &quot;cluster.routing.allocation.exclude._ip&quot;: &quot;ip1,ip2,ip3,ip4&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现此时集群上这4个节点分别有一个分片开始进行move, what for? 按我们的理解, move操作的并发应该被我们通过参数<code>cluster_concurrent_rebalance</code>控制为1, 可是为啥为4。好像这个下线节点时候shard的并发与下线节点个数一致, 而不是受我们控制。</p>
<h2 id="现象2"><a href="#现象2" class="headerlink" title="现象2"></a>现象2</h2><p>首先向集群发送如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;transient&quot;: &#123;</span><br><span class="line">        &quot;cluster&quot;: &#123;</span><br><span class="line">         &quot;routing&quot;: &#123;</span><br><span class="line">            &quot;rebalance&quot;: &#123;</span><br><span class="line">               &quot;enable&quot;: &quot;all&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;allocation&quot;: &#123;</span><br><span class="line">               &quot;allow_rebalance&quot;: &quot;always&quot;,</span><br><span class="line">               &quot;cluster_concurrent_rebalance&quot;: &quot;0&quot;,</span><br><span class="line">               &quot;node_concurrent_recoveries&quot;: &quot;0&quot;,</span><br><span class="line">               &quot;node_initial_primaries_recoveries&quot;: &quot;0&quot;,</span><br><span class="line">               &quot;enable&quot;: &quot;all&quot;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我通过如下命令下线4个节点:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT _cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;transient&quot;: &#123;</span><br><span class="line">         &quot;cluster.routing.allocation.exclude._ip&quot;: &quot;ip1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>集群突然有144个分片处于move中，按道理node_concurrent_recoveries&#x3D;0后， 集群将不会再有分片move。实际原因是参数<code>cluster.routing.allocation.node_concurrent_incoming_recoveries</code>和<code>cluster.routing.allocation.node_concurrent_outgoing_recoveries</code>的初始化可以由<code>cluster.routing.allocation.node_concurrent_recoveries</code>赋值， 但是之后对<code>cluster.routing.allocation.node_concurrent_recoveries</code>的修改，将不会影响incoming和outgoing的取值， 此时这两个参数任然是50。所以就产生了<code>node_concurrent_recoveries=0</code>、集群还有较大的move.</p>
<h1 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h1><p>带着上面的疑问, 试图从代码中找到原因, 我们知道, 任何集群元数据变动都会跳到BalancedShardsAllocator.allocate():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void allocate(RoutingAllocation allocation) &#123;</span><br><span class="line">    if (allocation.routingNodes().size() == 0) &#123;</span><br><span class="line">        /* with no nodes this is pointless */</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    final Balancer balancer = new Balancer(logger, allocation, weightFunction, threshold);</span><br><span class="line">    balancer.allocateUnassigned();</span><br><span class="line">    balancer.moveShards();</span><br><span class="line">    balancer.balance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里操作都是依据分片分配到各个节点的打分为依据来操作, 主要分为三步: 分配unassigned分片, move分片, 均衡分片。 在开始的现象, 明显不是第一步, 只可能是move分片、或者均衡分片。</p>
<h2 id="move分片"><a href="#move分片" class="headerlink" title="move分片"></a>move分片</h2><p>我们首先进入move分片看下能否解释现象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void moveShards() &#123;</span><br><span class="line">    // Iterate over the started shards interleaving between nodes, and check if they can remain. In the presence of throttling</span><br><span class="line">    // shard movements, the goal of this iteration order is to achieve a fairer movement of shards from the nodes that are</span><br><span class="line">    // offloading the shards.</span><br><span class="line">    //实际上，每次moveShards只会从每个node中选择一个shard迁移</span><br><span class="line">    for (Iterator&lt;ShardRouting&gt; it = allocation.routingNodes().nodeInterleavedShardIterator(); it.hasNext(); ) &#123;</span><br><span class="line">        ShardRouting shardRouting = it.next();</span><br><span class="line">        final MoveDecision moveDecision = decideMove(shardRouting);</span><br><span class="line">        if (moveDecision.isDecisionTaken() &amp;&amp; moveDecision.forceMove()) &#123;</span><br><span class="line">            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());</span><br><span class="line">            final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId());</span><br><span class="line">            sourceNode.removeShard(shardRouting);</span><br><span class="line">            Tuple&lt;ShardRouting, ShardRouting&gt; relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),</span><br><span class="line">                allocation.clusterInfo().getShardSize(shardRouting, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes());</span><br><span class="line">            targetNode.addShard(relocatingShards.v2());</span><br><span class="line">            if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(&quot;Moved shard [&#123;&#125;] to node [&#123;&#125;]&quot;, shardRouting, targetNode.getRoutingNode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (moveDecision.isDecisionTaken() &amp;&amp; moveDecision.canRemain() == false) &#123;</span><br><span class="line">            logger.trace(&quot;[&#123;&#125;][&#123;&#125;] can&apos;t move&quot;, shardRouting.index(), shardRouting.id());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要注意一个事实: 这里轮循所有分片是有顺序的, 依次从每个节点上选择一个分片判断, 首先第一轮: 选择第一个节点上的第一个分片, 然后第二个节点上的第一个分片…, 最后一个节点的第一个分片, 再开始第二轮: 第一个节点上第二个分片……。<br>然后再进入decideMove看下具体的move的逻辑:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Makes a decision on whether to move a started shard to another node.  The following rules apply</span><br><span class="line"> * to the &#123;@link MoveDecision&#125; return object:</span><br><span class="line"> *   1. If the shard is not started, no decision will be taken and &#123;@link MoveDecision#isDecisionTaken()&#125; will return false.</span><br><span class="line"> *   2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and</span><br><span class="line"> *      &#123;@link MoveDecision#canRemainDecision&#125; will have a decision type of YES.  All other fields in the object will be null.</span><br><span class="line"> *   3. If the shard is not allowed to remain on its current node, then &#123;@link MoveDecision#getAllocationDecision()&#125; will be</span><br><span class="line"> *      populated with the decision of moving to another node.  If &#123;@link MoveDecision#forceMove()&#125; ()&#125; returns &#123;@code true&#125;, then</span><br><span class="line"> *      &#123;@link MoveDecision#targetNode&#125; will return a non-null value, otherwise the assignedNodeId will be null.</span><br><span class="line"> *   4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then</span><br><span class="line"> *      &#123;@link MoveDecision#nodeDecisions&#125; will have a non-null value.</span><br><span class="line"> */</span><br><span class="line">public MoveDecision decideMove(final ShardRouting shardRouting) &#123;</span><br><span class="line">    if (shardRouting.started() == false) &#123;</span><br><span class="line">        // we can only move started shards</span><br><span class="line">        return MoveDecision.NOT_TAKEN;</span><br><span class="line">    &#125;</span><br><span class="line">    final boolean explain = allocation.debugDecision();</span><br><span class="line">    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());</span><br><span class="line">    assert sourceNode != null &amp;&amp; sourceNode.containsShard(shardRouting);</span><br><span class="line">    RoutingNode routingNode = sourceNode.getRoutingNode();</span><br><span class="line">    Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation);  //确定该节点是否还能存储在当前节点上</span><br><span class="line">    if (canRemain.type() != Decision.Type.NO) &#123;</span><br><span class="line">        return MoveDecision.stay(canRemain);</span><br><span class="line">    &#125;</span><br><span class="line">    sorter.reset(shardRouting.getIndexName());</span><br><span class="line">    /*</span><br><span class="line">     * the sorter holds the minimum weight node first for the shards index.</span><br><span class="line">     * We now walk through the nodes until we find a node to allocate the shard.</span><br><span class="line">     * This is not guaranteed to be balanced after this operation we still try best effort to</span><br><span class="line">     * allocate on the minimal eligible node.</span><br><span class="line">     */</span><br><span class="line">    Type bestDecision = Type.NO;</span><br><span class="line">    RoutingNode targetNode = null;</span><br><span class="line">    final List&lt;NodeAllocationResult&gt; nodeExplanationMap = explain ? new ArrayList&lt;&gt;() : null;</span><br><span class="line">    int weightRanking = 0;</span><br><span class="line">    for (ModelNode currentNode : sorter.modelNodes) &#123;</span><br><span class="line">        if (currentNode != sourceNode) &#123;</span><br><span class="line">            RoutingNode target = currentNode.getRoutingNode();</span><br><span class="line">            // don&apos;t use canRebalance as we want hard filtering rules to apply. See #17698</span><br><span class="line">            // 查看当前分片</span><br><span class="line">            Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation);</span><br><span class="line">            if (explain) &#123;</span><br><span class="line">                nodeExplanationMap.add(new NodeAllocationResult(</span><br><span class="line">                    currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking));</span><br><span class="line">            &#125;</span><br><span class="line">            // TODO maybe we can respect throttling here too?</span><br><span class="line">            if (allocationDecision.type().higherThan(bestDecision)) &#123;</span><br><span class="line">                bestDecision = allocationDecision.type();</span><br><span class="line">                if (bestDecision == Type.YES) &#123;</span><br><span class="line">                    targetNode = target;</span><br><span class="line">                    if (explain == false) &#123;</span><br><span class="line">                        // we are not in explain mode and already have a YES decision on the best weighted node,</span><br><span class="line">                        // no need to continue iterating</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),</span><br><span class="line">        targetNode != null ? targetNode.node() : null, nodeExplanationMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要做了如下逻辑:</p>
<ul>
<li>若该分片不处于Started, 那么将不进行move。</li>
<li>首先通过canRemain检查该分片是否还可以继续存留在该节点上, 主要由以下几个因素决定:</li>
</ul>
<ol>
<li>awareness(机房)</li>
<li>磁盘空间</li>
<li>ip排除(就是本次修改的参数)</li>
<li>每个节点上最多分配个数(total_shards_per_node)。<br>很显然, 本次过程中ip排除了,那么该分片不能再待在本节点上了。</li>
</ol>
<ul>
<li>那么在所有节点上找一个节点, 该分片可以迁移上去。找的依据是canAllocate, canAllocate决定因素并没有包含cluster_concurrent_rebalance, 但是增加了node_concurrent_outgoing_recoveries、node_concurrent_incoming_recoveries。这两个参数的含义是: 决定分片是否可以分配到某个节点上的依据是该节点上正在迁入&#x2F;迁出的分片是否达到阈值, 若没有达到阈值, 就可以分配。<br><code>重点:</code> 这就解释了为啥通过调整_ip时, 为啥不能通过cluster_concurrent_rebalance控制rebalance的并发了, ip调整时并发是通过迁入&#x2F;迁出并发控制的, 也就是我们最开始观察到的现象, 正因为我们设置了node_concurrent_recoveries, 导致每个分片上迁出并发只能是1, 那么设置exclude.ip为4个时, 我们在前端看到有4个分片正处于rebalance。这里完全都没想过使用cluster_concurrent_rebalance来控制迁移并发的。这里不用cluster_concurrent_rebalance, 官方也给出了<a href="https://github.com/elastic/elasticsearch/pull/17698" target="_blank" rel="noopener">原因</a>:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#14259 added a check to honor rebalancing policies (i.e., rebalance only on green state) when moving shards due to changes in allocation filtering rules. The rebalancing policy is there to make sure that we don&apos;t try to even out the number of shards per node when we are still missing shards. However, it should not interfere with explicit user commands (allocation filtering) or things like the disk threshold wanting to move shards because of a node hitting the high water mark.</span><br><span class="line">#14259 was done to address #14057 where people reported that using allocation filtering caused many shards to be moved at once. This is however a none issue - with 1.7 (where the issue was reported) and 2.x, we protect recovery source nodes by limitting the number of concurrent data streams they can open (i.e., we can have many recoveries, but they will be throttled). In 5.0 we came up with a simpler and more understandable approach where we have a hard limit on the number of outgoing recoveries per node (on top of the incoming recoveries we already had).</span><br></pre></td></tr></table></figure></li>
</ul>
<p>大致就是说, rebalance策略主要是为了解决的是: 当我们未对全局分片有足够了解的时候(当全局分片并未处于完全均衡的时候), 我们并不会去干扰每个节点的分片个数。当然, rebalance更不应该去干扰显示的用户命令比如分片排除, 或者达到磁盘阈值这样的情况。这里并发是通过Incoming&#x2F;OutComing这样的并发去控制的。原因清楚了吧。</p>
<ul>
<li>找到一个可以迁移到分片后, 然后通过routingNodes.relocateShard修改relocatingShards值, 这个值就是我们在前端看到的正在rebalance的个数。</li>
</ul>
<h2 id="均衡分片"><a href="#均衡分片" class="headerlink" title="均衡分片"></a>均衡分片</h2><p>既然现象是由move分片来解释了, 那么我们也来了解均衡分片大致做了那些事情呢?</p>
<ul>
<li>通过allocation.deciders().canRebalance(allocation).type() 首先检查是否可以进行rebalance。通过ClusterRebalanceType来控制:</li>
</ul>
<ol>
<li>若设置为ALWAYS, 那么是可以进行rebalance的。</li>
<li>若设置为INDICES_PRIMARIES_ACTIVE, 那么当只有所有主分片处于active的时候才可以进行rebalance的。</li>
<li>若设置为INDICES_ALL_ACTIVE, 那么是禁止rebalance的。</li>
</ol>
<ul>
<li>若可以进行rebalance, 然后进入balanceByWeights()。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">private void balanceByWeights() &#123;</span><br><span class="line">    final AllocationDeciders deciders = allocation.deciders();</span><br><span class="line">    final ModelNode[] modelNodes = sorter.modelNodes;</span><br><span class="line">    final float[] weights = sorter.weights;</span><br><span class="line">    //轮循所有索引</span><br><span class="line">    for (String index : buildWeightOrderedIndices()) &#123;</span><br><span class="line">        IndexMetaData indexMetaData = metaData.index(index);</span><br><span class="line">        // find nodes that have a shard of this index or where shards of this index are allowed to be allocated to,</span><br><span class="line">        // move these nodes to the front of modelNodes so that we can only balance based on these nodes</span><br><span class="line">        // 首先选择与该索引有关的节点, 这些节点, 那么该索引有分配在上面分配, 要么该索引可以分配到该节点上。默认情况下, 除了exclude外, 所有节点都是相关的。</span><br><span class="line">        int relevantNodes = 0;</span><br><span class="line">        for (int i = 0; i &lt; modelNodes.length; i++) &#123;</span><br><span class="line">            ModelNode modelNode = modelNodes[i];</span><br><span class="line">            if (modelNode.getIndex(index) != null</span><br><span class="line">                || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) &#123;</span><br><span class="line">                // swap nodes at position i and relevantNodes</span><br><span class="line">                modelNodes[i] = modelNodes[relevantNodes];</span><br><span class="line">                modelNodes[relevantNodes] = modelNode;</span><br><span class="line">                relevantNodes++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 若相关节点少于2个,就没有rebalance的必要了</span><br><span class="line">        if (relevantNodes &lt; 2) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对相关节点与该索引之间进行打分, 分值从最小到最大进行排序(分值越大说明分配越不合理)</span><br><span class="line">        sorter.reset(index, 0, relevantNodes);</span><br><span class="line">        int lowIdx = 0;</span><br><span class="line">        int highIdx = relevantNodes - 1;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            final ModelNode minNode = modelNodes[lowIdx];</span><br><span class="line">            final ModelNode maxNode = modelNodes[highIdx];</span><br><span class="line">            advance_range:</span><br><span class="line">            // 假如最大分值的节点, 该索引有分片存在</span><br><span class="line">            if (maxNode.numShards(index) &gt; 0) &#123;</span><br><span class="line">                //计算最大和最小分值差大于阈值</span><br><span class="line">                final float delta = absDelta(weights[lowIdx], weights[highIdx]);</span><br><span class="line">                //若差值小于阈值1</span><br><span class="line">                if (lessThan(delta, threshold)) &#123;</span><br><span class="line"></span><br><span class="line">                    if (lowIdx &gt; 0 &amp;&amp; highIdx-1 &gt; 0 // is there a chance for a higher delta?</span><br><span class="line">                        &amp;&amp; (absDelta(weights[0], weights[highIdx-1]) &gt; threshold) // check if we need to break at all</span><br><span class="line">                        ) &#123;  //low和high差距大于阈值，那么还是可以继续找的</span><br><span class="line">                        /* This is a special case if allocations from the &quot;heaviest&quot; to the &quot;lighter&quot; nodes is not possible</span><br><span class="line">                         * due to some allocation decider restrictions like zone awareness. if one zone has for instance</span><br><span class="line">                         * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we</span><br><span class="line">                         * can&apos;t move to the &quot;lighter&quot; shards since otherwise the zone would go over capacity.</span><br><span class="line">                         *</span><br><span class="line">                         * This break jumps straight to the condition below were we start moving from the high index towards</span><br><span class="line">                         * the low index to shrink the window we are considering for balance from the other direction.</span><br><span class="line">                         * (check shrinking the window from MAX to MIN)</span><br><span class="line">                         * See #3580</span><br><span class="line">                         */</span><br><span class="line">                        break advance_range;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                        logger.trace(&quot;Stop balancing index [&#123;&#125;]  min_node [&#123;&#125;] weight: [&#123;&#125;]  max_node [&#123;&#125;] weight: [&#123;&#125;]  delta: [&#123;&#125;]&quot;,</span><br><span class="line">                                index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break; //low和high差距小于阈值，那么完全不用找了。直接退出当前索引的rebalance，进行下一个索引的rebalance</span><br><span class="line">                &#125;</span><br><span class="line">                if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(&quot;Balancing from node [&#123;&#125;] weight: [&#123;&#125;] to node [&#123;&#125;] weight: [&#123;&#125;]  delta: [&#123;&#125;]&quot;,</span><br><span class="line">                            maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);</span><br><span class="line">                &#125;</span><br><span class="line">                /* pass the delta to the replication function to prevent relocations that only swap the weights of the two nodes.</span><br><span class="line">                 * a relocation must bring us closer to the balance if we only achieve the same delta the relocation is useless */</span><br><span class="line">                if (tryRelocateShard(minNode, maxNode, index, delta)) &#123;</span><br><span class="line">                    /*</span><br><span class="line">                     * TODO we could be a bit smarter here, we don&apos;t need to fully sort necessarily</span><br><span class="line">                     * we could just find the place to insert linearly but the win might be minor</span><br><span class="line">                     * compared to the added complexity</span><br><span class="line">                     */</span><br><span class="line">                    weights[lowIdx] = sorter.weight(modelNodes[lowIdx]);</span><br><span class="line">                    weights[highIdx] = sorter.weight(modelNodes[highIdx]);</span><br><span class="line">                    sorter.sort(0, relevantNodes);</span><br><span class="line">                    lowIdx = 0;</span><br><span class="line">                    highIdx = relevantNodes - 1;</span><br><span class="line">                    // 再继续查找当前索引在别的节点上是都有更合适的分配。</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 若没有分配, 则开始low+1 进行第二轮重新开始。</span><br><span class="line">            //第一轮：首先第一轮从high不变， low每次增加1，向higt靠近，直到low和high一样， 第二轮：然后high--， 继续low向higt靠近；再第三轮，这样实际循环次数是(high-low)(high-low)/2, 很像一个倒着的乘法表</span><br><span class="line">            if (lowIdx &lt; highIdx - 1) &#123;</span><br><span class="line">                /* Shrinking the window from MIN to MAX</span><br><span class="line">                 * we can&apos;t move from any shard from the min node lets move on to the next node</span><br><span class="line">                 * and see if the threshold still holds. We either don&apos;t have any shard of this</span><br><span class="line">                 * index on this node of allocation deciders prevent any relocation.*/</span><br><span class="line">                lowIdx++;</span><br><span class="line">            &#125; else if (lowIdx &gt; 0) &#123;</span><br><span class="line">                /* Shrinking the window from MAX to MIN</span><br><span class="line">                 * now we go max to min since obviously we can&apos;t move anything to the max node</span><br><span class="line">                 * lets pick the next highest */</span><br><span class="line">                lowIdx = 0;</span><br><span class="line">                highIdx--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* we are done here, we either can&apos;t relocate anymore or we are balanced */</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>rebalance时, 以index来循环, 大概逻辑就是:</p>
<ol>
<li>针对每个索引在每个节点上分配进行一个打分。打分依据是(该索引是否在所有节点是否分配均衡&amp;&amp;所有shard是否在所有节点分配均衡), 分支越低, 说明分配越合理。</li>
<li>从分值高低差的阈值来判断是否需要rebalance。阈值为1。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>若仅仅增加节点, 那么就是rebalance操作, 此时cluster_concurrent_rebalance是生效的。 若做了exclude操作, 那么就变成了move操作, 此时node_concurrent_recoveries就该生效了。 move, rebalance, allocation等操作都是由多个决策器一起决定如何分配的, 只要合理使用各种决策器, 那么分片分配就能被我们合理的掌握了。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/elasticsearch_learning/categories/Elasticsearch//" class="article-tag-list-link color4">Elasticsearch</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/elasticsearch_learning/2019/06/16/ES原理-下线节点时分片并发rebalance的思考/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Flink原理-Container启动命令内存参数分析" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/elasticsearch_learning/2019/06/08/Flink原理-Container启动命令内存参数分析/">Flink原理-Container启动命令内存参数分析</a>
    </h1>
  

        
        <a href="/elasticsearch_learning/2019/06/08/Flink原理-Container启动命令内存参数分析/" class="archive-article-date">
  	<time datetime="2019-06-08T11:22:29.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-06-08</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>如下是flink on yarn启动的一个示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/flink run -m yarn-cluster -yd -yjm 1024 -ys 2 -ytm 2048 clink-with-dependencies.jar  --topic_name topic1 --log_name --source_num 50  --sink_num 50</span><br></pre></td></tr></table></figure>

<p>其中我们定义了JobManager的大小为1024M, TaskManager大小为2048M, 但是通过实际观察发现JobManager heap大小为424M, TaskManager heap memory大小为1304M, direct memory大小为744M , 参数值为啥是这个呢?</p>
<h1 id="JobManager内存参数设置"><a href="#JobManager内存参数设置" class="headerlink" title="JobManager内存参数设置"></a>JobManager内存参数设置</h1><p>可以看到, JM内存设置与实际严重不符, 我们直接上代码找下原因吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">121390 YarnJobClusterEntrypoint -Xmx424m -Dlog.file=/opt/xxxx/hadoop-flink/hadoop-2.7.1/logs/userlogs/application_1554212859057_0525/container_1554212859057_0525_01_000001/jobmanager.log -Dlogback.configurationFile=file:logback.xml -Dlog4j.configuration=file:log4j.properties</span><br></pre></td></tr></table></figure>

<p>JM启动命令的产生是在AbstractYarnClusterDescriptor.startAppMaster()中, 最终进入了setupApplicationMasterContainer()中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">protected ContainerLaunchContext setupApplicationMasterContainer(</span><br><span class="line">		String yarnClusterEntrypoint, //获取的是org.apache.flink.yarn.entrypoint.YarnJobClusterEntrypoint</span><br><span class="line">		boolean hasLogback,</span><br><span class="line">		boolean hasLog4j,</span><br><span class="line">		boolean hasKrb5,</span><br><span class="line">		int jobManagerMemoryMb) &#123;</span><br><span class="line">	// ------------------ Prepare Application Master Container  ------------------------------</span><br><span class="line">	// respect custom JVM options in the YAML file</span><br><span class="line">	String javaOpts = flinkConfiguration.getString(CoreOptions.FLINK_JVM_OPTIONS);</span><br><span class="line">	if (flinkConfiguration.getString(CoreOptions.FLINK_JM_JVM_OPTIONS).length() &gt; 0) &#123;</span><br><span class="line">		javaOpts += &quot; &quot; + flinkConfiguration.getString(CoreOptions.FLINK_JM_JVM_OPTIONS);</span><br><span class="line">	&#125;</span><br><span class="line">	// Set up the container launch context for the application master</span><br><span class="line">	ContainerLaunchContext amContainer = Records.newRecord(ContainerLaunchContext.class);</span><br><span class="line">	final  Map&lt;String, String&gt; startCommandValues = new HashMap&lt;&gt;();</span><br><span class="line">	startCommandValues.put(&quot;java&quot;, &quot;$JAVA_HOME/bin/java&quot;);</span><br><span class="line">	startCommandValues.put(&quot;jvmmem&quot;, &quot;-Xmx&quot; +</span><br><span class="line">		Utils.calculateHeapSize(jobManagerMemoryMb, flinkConfiguration) +</span><br><span class="line">		&quot;m&quot;);</span><br><span class="line">	startCommandValues.put(&quot;jvmopts&quot;, javaOpts);</span><br><span class="line">	String logging = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">      //构建启动命令，class指定了申请的container启动哪个主函数，也就是jm  applicationMaster的地址</span><br><span class="line">	startCommandValues.put(&quot;logging&quot;, logging);</span><br><span class="line">	startCommandValues.put(&quot;class&quot;, yarnClusterEntrypoint);   //获取的是org.apache.flink.yarn.entrypoint.YarnJobClusterEntrypoint</span><br><span class="line">	startCommandValues.put(&quot;redirects&quot;,</span><br><span class="line">		&quot;1&gt; &quot; + ApplicationConstants.LOG_DIR_EXPANSION_VAR + &quot;/jobmanager.out &quot; +</span><br><span class="line">		&quot;2&gt; &quot; + ApplicationConstants.LOG_DIR_EXPANSION_VAR + &quot;/jobmanager.err&quot;);</span><br><span class="line">	startCommandValues.put(&quot;args&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">	final String commandTemplate = flinkConfiguration  // jm 启动默认命令</span><br><span class="line">		.getString(ConfigConstants.YARN_CONTAINER_START_COMMAND_TEMPLATE,</span><br><span class="line">			ConfigConstants.DEFAULT_YARN_CONTAINER_START_COMMAND_TEMPLATE);</span><br><span class="line">	final String amCommand =</span><br><span class="line">		BootstrapTools.getStartCommand(commandTemplate, startCommandValues); //获取真正的 jm  启动命令</span><br><span class="line"></span><br><span class="line">	// 真正去通过yarn调度启动JM</span><br><span class="line">	amContainer.setCommands(Collections.singletonList(amCommand));</span><br><span class="line">	return amContainer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, JM启动默认只设置了-Xmx, 在Utils.calculateHeapSize(jobManagerMemoryMb)中设置了,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static int calculateHeapSize(int memory, org.apache.flink.configuration.Configuration conf) &#123;</span><br><span class="line">       // container占用比率,containerized.heap-cutoff-ratio, 默认25%</span><br><span class="line">	float memoryCutoffRatio = conf.getFloat(ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO);</span><br><span class="line">	// container占用最小内存大小: containerized.heap-cutoff-min, 最少600mb</span><br><span class="line">	int minCutoff = conf.getInteger(ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN);</span><br><span class="line">	if (memoryCutoffRatio &gt; 1 || memoryCutoffRatio &lt; 0) &#123;</span><br><span class="line">		throw new IllegalArgumentException(&quot;The configuration value &apos;&quot;</span><br><span class="line">			+ ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO.key()</span><br><span class="line">			+ &quot;&apos; must be between 0 and 1. Value given=&quot; + memoryCutoffRatio);</span><br><span class="line">	&#125;</span><br><span class="line">	if (minCutoff &gt; memory) &#123;</span><br><span class="line">		throw new IllegalArgumentException(&quot;The configuration value &apos;&quot;</span><br><span class="line">			+ ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN.key()</span><br><span class="line">			+ &quot;&apos; is higher (&quot; + minCutoff + &quot;) than the requested amount of memory &quot; + memory);</span><br><span class="line">	&#125;</span><br><span class="line">	int heapLimit = (int) ((float) memory * memoryCutoffRatio);</span><br><span class="line">	if (heapLimit &lt; minCutoff) &#123;</span><br><span class="line">		heapLimit = minCutoff;</span><br><span class="line">	&#125;</span><br><span class="line">	return memory - heapLimit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, JM启动时, 去掉yarn container占用内存大小, 即为JM大小。 container大小为20%*heap, 但是不得小于600MB,  这里当然只能600M, 所以剩余JM heap大小为(1024-600)MB&#x3D;424MB。</p>
<h1 id="TaskManager内存参数设置"><a href="#TaskManager内存参数设置" class="headerlink" title="TaskManager内存参数设置"></a>TaskManager内存参数设置</h1><p>如下是TM启动后的参数, 可以发现, 堆内内存+对外内存&#x3D;申请的内存, 那么这个内存如何确定比例的?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">183863 YarnTaskExecutorRunner -Xms1304m -Xmx1304m -XX:MaxDirectMemorySize=744m -Dlog.file=/opt/xxxx/hadoop-flink/hadoop-2.7.1/logs/userlogs/application_1554212859057_0525/container_1554212859057_0525_01_000003/taskmanager.log -Dlogback.configurationFile=file:./logback.xml -Dlog4j.configuration=file:./log4j.properties</span><br></pre></td></tr></table></figure>

<p>当JM为TM申请container成功后, 在<a href="https://kkewwei.github.io/elasticsearch_learning/2019/03/12/Flink%E5%8E%9F%E7%90%86-slot%E5%88%86%E9%85%8D/#%E7%94%B3%E8%AF%B7container%E6%88%90%E5%8A%9F">createTaskExecutorLaunchContext</a>中确定JM启动参数, 最终进入到了ContaineredTaskManagerParameters.create中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static ContaineredTaskManagerParameters create(</span><br><span class="line">		Configuration config,</span><br><span class="line">		long containerMemoryMB,</span><br><span class="line">		int numSlots) &#123;</span><br><span class="line">	// (1) try to compute how much memory used by container</span><br><span class="line">	// 首先确定yarn Container使用多少内存(算是堆外内存)</span><br><span class="line">	final long cutoffMB = calculateCutoffMB(config, containerMemoryMB);</span><br><span class="line"></span><br><span class="line">	// (2) split the remaining Java memory between heap and off-heap</span><br><span class="line">	//确定堆内内存大小</span><br><span class="line">	final long heapSizeMB = TaskManagerServices.calculateHeapSizeMB(containerMemoryMB - cutoffMB, config);</span><br><span class="line">	// use the cut-off memory for off-heap (that was its intention)</span><br><span class="line">	// 堆内内存以外的全是堆内内存</span><br><span class="line">	final long offHeapSizeMB = containerMemoryMB - heapSizeMB;</span><br><span class="line"></span><br><span class="line">	// (3) obtain the additional environment variables from the configuration</span><br><span class="line">	final HashMap&lt;String, String&gt; envVars = new HashMap&lt;&gt;();</span><br><span class="line">	final String prefix = ResourceManagerOptions.CONTAINERIZED_TASK_MANAGER_ENV_PREFIX;</span><br><span class="line"></span><br><span class="line">	for (String key : config.keySet()) &#123;</span><br><span class="line">		if (key.startsWith(prefix) &amp;&amp; key.length() &gt; prefix.length()) &#123;</span><br><span class="line">			// remove prefix</span><br><span class="line">			String envVarKey = key.substring(prefix.length());</span><br><span class="line">			envVars.put(envVarKey, config.getString(key, null));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// done</span><br><span class="line">	return new ContaineredTaskManagerParameters(</span><br><span class="line">		containerMemoryMB, heapSizeMB, offHeapSizeMB, numSlots, envVars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要做了如下逻辑:</p>
<ol>
<li>确定yarn container本身需要的内存(算是堆外内存)。</li>
<li>确定堆内的内存大小。</li>
<li>确定堆外内存大小, 不是堆内的内存就全部算是堆外内存。<br>首先我们看下如何确定yarn container大小的:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static long calculateCutoffMB(Configuration config, long containerMemoryMB) &#123;</span><br><span class="line">	Preconditions.checkArgument(containerMemoryMB &gt; 0);</span><br><span class="line">	// (1) check cutoff ratio  // 默认值0.25f</span><br><span class="line">	final float memoryCutoffRatio = config.getFloat(</span><br><span class="line">		ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO);</span><br><span class="line">	// (2) check min cutoff value   最少预留大小默认600MB</span><br><span class="line">	final int minCutoff = config.getInteger(</span><br><span class="line">		ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN);</span><br><span class="line">	// (3) check between heap and off-heap</span><br><span class="line">	long cutoff = (long) (containerMemoryMB * memoryCutoffRatio);</span><br><span class="line">	//取最大值</span><br><span class="line">	if (cutoff &lt; minCutoff) &#123;</span><br><span class="line">		cutoff = minCutoff;</span><br><span class="line">	&#125;</span><br><span class="line">	return cutoff;  //至少预留600MB，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>yarn container大小取值原则: 在申请内存的containerized.heap-cutoff-ratio(默认25%)与containerized.heap-cutoff-min(默认600M)之前取最大值。本示例中, container占用600M<br>接下来我们看下如何确定堆内内存的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static long calculateHeapSizeMB(long totalJavaMemorySizeMB, Configuration config) &#123;</span><br><span class="line">	// subtract the Java memory used for network buffers (always off-heap)</span><br><span class="line">	//  网络buffer, 最小64M，最大1GB, 是totalJavaMemorySizeMB*0.1</span><br><span class="line">	final long networkBufMB =</span><br><span class="line">		calculateNetworkBufferMemory(</span><br><span class="line">			totalJavaMemorySizeMB &lt;&lt; 20, // megabytes to bytes</span><br><span class="line">			config) &gt;&gt; 20; // bytes to megabytes</span><br><span class="line">	final long remainingJavaMemorySizeMB = totalJavaMemorySizeMB - networkBufMB;</span><br><span class="line">	// split the available Java memory between heap and off-heap</span><br><span class="line">	final boolean useOffHeap = config.getBoolean(TaskManagerOptions.MEMORY_OFF_HEAP);  // 默认为false</span><br><span class="line"></span><br><span class="line">	final long heapSizeMB;</span><br><span class="line">	if (useOffHeap) &#123;// 默认线上是关闭的</span><br><span class="line">		long offHeapSize;</span><br><span class="line">		String managedMemorySizeDefaultVal = TaskManagerOptions.MANAGED_MEMORY_SIZE.defaultValue();</span><br><span class="line">		if (!config.getString(TaskManagerOptions.MANAGED_MEMORY_SIZE).equals(managedMemorySizeDefaultVal)) &#123;</span><br><span class="line">			try &#123;// 将划去networkBuffer大小*一个堆外的系数（默认是0.7）得到其他的堆外内存</span><br><span class="line">				offHeapSize = MemorySize.parse(config.getString(TaskManagerOptions.MANAGED_MEMORY_SIZE), MEGA_BYTES).getMebiBytes();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			offHeapSize = Long.valueOf(managedMemorySizeDefaultVal);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (offHeapSize &lt;= 0) &#123;</span><br><span class="line">			// calculate off-heap section via fraction</span><br><span class="line">			double fraction = config.getFloat(TaskManagerOptions.MANAGED_MEMORY_FRACTION);</span><br><span class="line">			offHeapSize = (long) (fraction * remainingJavaMemorySizeMB);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		TaskManagerServicesConfiguration</span><br><span class="line">			.checkConfigParameter(offHeapSize &lt; remainingJavaMemorySizeMB, offHeapSize,</span><br><span class="line">				TaskManagerOptions.MANAGED_MEMORY_SIZE.key(),</span><br><span class="line">				&quot;Managed memory size too large for &quot; + networkBufMB +</span><br><span class="line">					&quot; MB network buffer memory and a total of &quot; + totalJavaMemorySizeMB +</span><br><span class="line">					&quot; MB JVM memory&quot;);</span><br><span class="line">		heapSizeMB = remainingJavaMemorySizeMB - offHeapSize;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		heapSizeMB = remainingJavaMemorySizeMB;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return heapSizeMB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存大小确定过程:</p>
<ol>
<li>首先确定网络buffer大小: 是totalJavaMemorySizeMB*0.1, 而且最小64M，最大1GB。 这里是(2048-600)*0.1MB&#x3D;144.8M。</li>
<li>剩余内存大小为(2048-600)*0.9MB&#x3D;1304MB。</li>
<li>在我们代码中, useOffHeap是false, 由taskmanager.memory.off-heap设置, 默认为false。<br>那么, TM启动的参数就很明显了, HEAP为1304MB, OFF-HEAD为2048MB-1304MB&#x3D;744MB(包括Container占用空闲+网络buffer)。</li>
</ol>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/elasticsearch_learning/categories/Flink//" class="article-tag-list-link color1">Flink</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/elasticsearch_learning/2019/06/08/Flink原理-Container启动命令内存参数分析/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Flink原理-Akka通信模块" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/elasticsearch_learning/2019/04/20/Flink原理-Akka通信模块/">Flink原理-Akka通信&amp;TaskManager注册</a>
    </h1>
  

        
        <a href="/elasticsearch_learning/2019/04/20/Flink原理-Akka通信模块/" class="archive-article-date">
  	<time datetime="2019-04-20T15:16:59.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-04-20</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Flink对于JobManager和TaskManager之间通信采用Akka remote实现, 本文将以tm和jm之间的一次远程通信为示例进行讲解。为了读者更好地理解, 本文首先介绍AKKa相关基本知识。</p>
<h1 id="Akka基础学习"><a href="#Akka基础学习" class="headerlink" title="Akka基础学习"></a>Akka基础学习</h1><p>本文首先以hello world为例进行讲解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class hello &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建系统</span><br><span class="line">        final ActorSystem system = ActorSystem.create(&quot;hello&quot;);</span><br><span class="line">        // 创建消息角色(): greeter1, 接受消息处理类: Greeter</span><br><span class="line">        final ActorRef greeter1 = system.actorOf(Props.create(Greeter.class), &quot;Sender1&quot;);</span><br><span class="line">        final ActorRef greeter2 = system.actorOf(Props.create(Greeter.class), &quot;Sender2&quot;);</span><br><span class="line">        //消息发送greeter1 -&gt;  greeter2, 消息内容&quot;tell1&quot;</span><br><span class="line">        greeter2.tell(&quot;tell1&quot;, greeter1);</span><br><span class="line"></span><br><span class="line">        //通过ask, 表示角色发送完消息, 希望对方返回。</span><br><span class="line">        Future&lt;String&gt; future  = Patterns.ask(greeter1, &quot;ask1&quot;, 5000).&lt;String&gt;mapTo(ClassTag$.MODULE$.&lt;String&gt;apply(String.class));</span><br><span class="line">        future.onComplete(new OnComplete&lt;String&gt;() &#123;</span><br><span class="line">            public void onComplete(Throwable throwable, String o) throws Throwable &#123;</span><br><span class="line">                if (throwable == null) &#123;</span><br><span class="line">                    System.out.println(o);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, system.dispatcher());</span><br><span class="line"></span><br><span class="line">        //获取greeter1的绝对路径</span><br><span class="line">        String url = greeter1.path().parent().toString()+&quot;/&quot;+greeter1.path().name()+&quot;#&quot;+greeter1.path().uid();</span><br><span class="line">        // 通过actorSelection, 可以查找角色, 这个函数比较重要, 我们只知道某个角色的绝对路径, 我们通过该函数, 就可以获取到该角色。一般用于远程数据传输。</span><br><span class="line">        ActorSelection actorSelection = system.actorSelection(url);</span><br><span class="line">        Future&lt;ActorIdentity&gt; identify  = Patterns.ask(actorSelection, new Identify(1), 5000).&lt;ActorIdentity&gt;mapTo(ClassTag$.MODULE$.&lt;ActorIdentity&gt;apply(ActorIdentity.class));</span><br><span class="line">        identify.onComplete(new OnComplete&lt;ActorIdentity&gt;() &#123;</span><br><span class="line">            public void onComplete(Throwable throwable, ActorIdentity o) throws Throwable &#123;</span><br><span class="line">                if (throwable != null) &#123;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // 我们可以对比发现, 之前那个角色通过绝对路径获取到了。</span><br><span class="line">                    ActorRef actorRef = o.getRef();</span><br><span class="line">                    System.out.println(&quot;system.actorSelection verify:&quot; + (actorRef==greeter1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, system.dispatcher());</span><br><span class="line">    &#125;</span><br><span class="line">    //消息处理类, 必须继承UntypedActor</span><br><span class="line">    public static class Greeter extends UntypedActor &#123;</span><br><span class="line">        // 消息角色真正接收到数据的函数</span><br><span class="line">        public void onReceive(Object message) &#123;</span><br><span class="line">            if(message instanceof String &amp;&amp; ((String)message).equals(&quot;tell1&quot;)) &#123;</span><br><span class="line">                System.out.println(message);</span><br><span class="line">                getSender().tell(&quot;word2&quot;, getSelf());</span><br><span class="line">            &#125; else if(message instanceof String &amp;&amp; ((String)message).equals(&quot;ask1&quot;)) &#123;</span><br><span class="line">                System.out.println(message);</span><br><span class="line">                // getSelf()表示本角色</span><br><span class="line">                getSender().tell(&quot;Patterns.ask()&quot;, getSelf());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.println(&quot;unhandled:&quot; + message);</span><br><span class="line">                unhandled(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tell1</span><br><span class="line">unhandled:word2</span><br><span class="line">ask1</span><br><span class="line">Patterns.ask()</span><br><span class="line">system.actorSelection verify:true</span><br></pre></td></tr></table></figure>

<ol>
<li>在使用actorSelection函数的时候, 我们需要了解一个关键字<a href="https://doc.akka.io/docs/akka/2.3.6/java/untyped-actors.html#actorselection-java" target="_blank" rel="noopener">Identify</a>, 它被定义为每个角色都知道其含义的消息, 当接收到Identify时, 角色自动回复ActorIdentity, 其中包含着对地址的角色。actorSelection可以获取该角色的引用, 这样就可以首先和该角色通信了。</li>
<li>ask和tell的区别是, ask希望对方角色返回结果, 而tell不需要返回结果。</li>
</ol>
<h1 id="Akka-RPC通信过程"><a href="#Akka-RPC通信过程" class="headerlink" title="Akka RPC通信过程"></a>Akka RPC通信过程</h1><h2 id="AkkaRpcService和RpcServer"><a href="#AkkaRpcService和RpcServer" class="headerlink" title="AkkaRpcService和RpcServer"></a>AkkaRpcService和RpcServer</h2><p>在正式介绍之前, 先介绍AkkaRpcService, 作为Flink Akka通信核心类, 它包含了akka通信系统ActorSystem, 任何角色产生, 都会调用RpcService.startServer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">   public &lt;C extends RpcEndpoint &amp; RpcGateway&gt; RpcServer startServer(C rpcEndpoint) &#123;</span><br><span class="line">	CompletableFuture&lt;Void&gt; terminationFuture = new CompletableFuture&lt;&gt;();</span><br><span class="line">	final Props akkaRpcActorProps;</span><br><span class="line">	if (rpcEndpoint instanceof FencedRpcEndpoint) &#123;</span><br><span class="line">		akkaRpcActorProps = Props.create(FencedAkkaRpcActor.class, rpcEndpoint, terminationFuture, getVersion());</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		akkaRpcActorProps = Props.create(AkkaRpcActor.class, rpcEndpoint, terminationFuture, getVersion());</span><br><span class="line">	&#125;</span><br><span class="line">	ActorRef actorRef;</span><br><span class="line">	synchronized (lock) &#123;</span><br><span class="line">		actorRef = actorSystem.actorOf(akkaRpcActorProps, rpcEndpoint.getEndpointId());</span><br><span class="line">		actors.put(actorRef, rpcEndpoint);</span><br><span class="line">	&#125;</span><br><span class="line">	LOG.info(&quot;Starting RPC endpoint for &#123;&#125; at &#123;&#125; .&quot;, rpcEndpoint.getClass().getName(), actorRef.path());</span><br><span class="line">	final String akkaAddress = AkkaUtils.getAkkaURL(actorSystem, actorRef);</span><br><span class="line">	final String hostname;</span><br><span class="line">	Option&lt;String&gt; host = actorRef.path().address().host();</span><br><span class="line">	if (host.isEmpty()) &#123;</span><br><span class="line">		hostname = &quot;localhost&quot;;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		hostname = host.get();</span><br><span class="line">	&#125;</span><br><span class="line">	Set&lt;Class&lt;?&gt;&gt; implementedRpcGateways = new HashSet&lt;&gt;(RpcUtils.extractImplementedRpcGateways(rpcEndpoint.getClass()));</span><br><span class="line">	implementedRpcGateways.add(RpcServer.class);</span><br><span class="line">	implementedRpcGateways.add(AkkaBasedEndpoint.class);</span><br><span class="line">	final InvocationHandler akkaInvocationHandler;</span><br><span class="line">	if (rpcEndpoint instanceof FencedRpcEndpoint) &#123;</span><br><span class="line">		// a FencedRpcEndpoint needs a FencedAkkaInvocationHandler</span><br><span class="line">		akkaInvocationHandler = new FencedAkkaInvocationHandler&lt;&gt;(</span><br><span class="line">			akkaAddress,</span><br><span class="line">			hostname,</span><br><span class="line">			actorRef,</span><br><span class="line">			timeout,</span><br><span class="line">			maximumFramesize,</span><br><span class="line">			terminationFuture,</span><br><span class="line">			((FencedRpcEndpoint&lt;?&gt;) rpcEndpoint)::getFencingToken);</span><br><span class="line">		implementedRpcGateways.add(FencedMainThreadExecutable.class);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		akkaInvocationHandler = new AkkaInvocationHandler(</span><br><span class="line">			akkaAddress,</span><br><span class="line">			hostname,</span><br><span class="line">			actorRef,</span><br><span class="line">			timeout,</span><br><span class="line">			maximumFramesize,</span><br><span class="line">			terminationFuture);</span><br><span class="line">	&#125;</span><br><span class="line">	ClassLoader classLoader = getClass().getClassLoader();</span><br><span class="line">	RpcServer server = (RpcServer) Proxy.newProxyInstance(</span><br><span class="line">		classLoader,</span><br><span class="line">		implementedRpcGateways.toArray(new Class&lt;?&gt;[implementedRpcGateways.size()]),</span><br><span class="line">		akkaInvocationHandler);</span><br><span class="line">	return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到:</p>
<ol>
<li>角色接收到信息后, 处理的类为FencedAkkaRpcActor&#x2F;AkkaRpcActor。</li>
<li>调用函数时的接口handler也分为FencedAkkaInvocationHandler&#x2F;AkkaInvocationHandler。每次代理GateWay请求时, 首先会调用AkkaInvocationHandler.invoke()类。<br>我们再来介绍下: RpcServer, RpcServer作为任何一个请求终端, 每次都将从相同的AkkaRpcService中参数, 实际封装了ActorRef来进行内部数据传输。</li>
</ol>
<h1 id="TM向JM注册"><a href="#TM向JM注册" class="headerlink" title="TM向JM注册"></a>TM向JM注册</h1><p>我们以TaskManager启动后, 会去主动连接JobMaster的ResourceManager, 以它们之间的通信为例进行讲解。YarnTaskExecutorRunner在运行主函数时, 会去调用TaskExecutor.connectToResourceManager()主动连接JobManager:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   private void connectToResourceManager() &#123;</span><br><span class="line">       log.info(&quot;Connecting to ResourceManager &#123;&#125;.&quot;, resourceManagerAddress);</span><br><span class="line">	resourceManagerConnection =</span><br><span class="line">		new TaskExecutorToResourceManagerConnection(</span><br><span class="line">			log,</span><br><span class="line">			getRpcService(),</span><br><span class="line">			getAddress(),</span><br><span class="line">			getResourceID(),</span><br><span class="line">			taskManagerLocation.dataPort(),</span><br><span class="line">			hardwareDescription,</span><br><span class="line">			resourceManagerAddress.getAddress(),</span><br><span class="line">			resourceManagerAddress.getResourceManagerId(),</span><br><span class="line">			getMainThreadExecutor(),</span><br><span class="line">			new ResourceManagerRegistrationListener());</span><br><span class="line">	resourceManagerConnection.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立好TaskExecutorToResourceManagerConnection之后,看下是如何操作的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">	final RetryingRegistration&lt;F, G, S&gt; newRegistration = createNewRegistration();</span><br><span class="line">	if (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) &#123;</span><br><span class="line">		newRegistration.startRegistration();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要做了如下事情:</p>
<ol>
<li>通过createNewRegistration构建ResourceManagerRegistration对象, 并没有做其他的事。同时在父类RetryingRegistration中定义了一个CompletableFuture, 当complete时候(成功向jm注册后), 会去调用TaskExecutorToResourceManagerConnection.onRegistrationSuccess(), 之后会详细介绍。</li>
<li>通过AkkaRpcService.startRegistration真正开始注册TaskManager。接下来看下如何向JobManager的ResourceManager注册该TaskManager。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   public void startRegistration() &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		// trigger resolution of the resource manager address to a callable gateway</span><br><span class="line">		final CompletableFuture&lt;G&gt; resourceManagerFuture;</span><br><span class="line">		if (FencedRpcGateway.class.isAssignableFrom(targetType)) &#123;</span><br><span class="line">		    //返回的就是clazz对象ResourceManagerGateway的代理</span><br><span class="line">			resourceManagerFuture = (CompletableFuture&lt;G&gt;) rpcService.connect(</span><br><span class="line">				targetAddress,</span><br><span class="line">				fencingToken,</span><br><span class="line">				targetType.asSubclass(FencedRpcGateway.class));</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			resourceManagerFuture = rpcService.connect(targetAddress, targetType);</span><br><span class="line">		&#125;</span><br><span class="line">		// upon success, start the registration attempts</span><br><span class="line">		CompletableFuture&lt;Void&gt; resourceManagerAcceptFuture = resourceManagerFuture.thenAcceptAsync(</span><br><span class="line">			(G result) -&gt; &#123;</span><br><span class="line">				log.info(&quot;Resolved &#123;&#125; address, beginning registration&quot;, targetName);</span><br><span class="line">				// 真正想远程JobManager进行注册</span><br><span class="line">				register(result, 1, initialRegistrationTimeout);</span><br><span class="line">			&#125;,</span><br><span class="line">			rpcService.getExecutor());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>主要逻辑如下:</p>
<ol>
<li>调用rpcService.connect, 获取代理, 代理中包含指向jobManager的ResourceManager的地址(akka.tcp:&#x2F;&#x2F;flink@jobmanager:port&#x2F;user&#x2F;resourcemanager)的角色, 以进行rpc通信。</li>
<li>当产生代理后, 再调用register进行真正RPC远程向JobManager的ResourceManager注册。</li>
</ol>
<h2 id="构建远程RPC调用的角色及代理"><a href="#构建远程RPC调用的角色及代理" class="headerlink" title="构建远程RPC调用的角色及代理"></a>构建远程RPC调用的角色及代理</h2><p>我们首先来看下是如何获取代理的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private &lt;C extends RpcGateway&gt; CompletableFuture&lt;C&gt; connectInternal(</span><br><span class="line">			final String address,</span><br><span class="line">			final Class&lt;C&gt; clazz,</span><br><span class="line">			Function&lt;ActorRef, InvocationHandler&gt; invocationHandlerFactory) &#123;</span><br><span class="line">		// 根据路径获取YarnResourceManager中JobManager ResourceManager的路径引用</span><br><span class="line">		final ActorSelection actorSel = actorSystem.actorSelection(address);</span><br><span class="line">		// 向该远程路径发送RPC请求, 获取对该远程路径的回话角色, 之后就可以向这个地址发送数据了</span><br><span class="line">		final Future&lt;ActorIdentity&gt; identify = Patterns</span><br><span class="line">			.ask(actorSel, new Identify(42), timeout.toMilliseconds())</span><br><span class="line">			.&lt;ActorIdentity&gt;mapTo(ClassTag$.MODULE$.&lt;ActorIdentity&gt;apply(ActorIdentity.class));</span><br><span class="line"></span><br><span class="line">		final CompletableFuture&lt;ActorIdentity&gt; identifyFuture = FutureUtils.toJava(identify);</span><br><span class="line">		final CompletableFuture&lt;ActorRef&gt; actorRefFuture = identifyFuture.thenApply(</span><br><span class="line">			(ActorIdentity actorIdentity) -&gt; &#123;</span><br><span class="line">				if (actorIdentity.getRef() == null) &#123;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">				    //获取对应的引用</span><br><span class="line">					return actorIdentity.getRef();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		// 发送handshake请求</span><br><span class="line">		final CompletableFuture&lt;HandshakeSuccessMessage&gt; handshakeFuture = actorRefFuture.thenCompose(</span><br><span class="line">			(ActorRef actorRef) -&gt; FutureUtils.toJava(</span><br><span class="line">				Patterns</span><br><span class="line">					.ask(actorRef, new RemoteHandshakeMessage(clazz, getVersion()), timeout.toMilliseconds())</span><br><span class="line">					.&lt;HandshakeSuccessMessage&gt;mapTo(ClassTag$.MODULE$.&lt;HandshakeSuccessMessage&gt;apply(HandshakeSuccessMessage.class))));</span><br><span class="line">		return actorRefFuture.thenCombineAsync(</span><br><span class="line">			handshakeFuture,</span><br><span class="line">			(ActorRef actorRef, HandshakeSuccessMessage ignored) -&gt; &#123;</span><br><span class="line">			    //获取FencedAkkaInvocationHandler</span><br><span class="line">				InvocationHandler invocationHandler = invocationHandlerFactory.apply(actorRef);</span><br><span class="line">				ClassLoader classLoader = getClass().getClassLoader();</span><br><span class="line">				@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">				// 构建针对ResourceManagerGateway的代理, handler为FencedAkkaInvocationHandler</span><br><span class="line">				C proxy = (C) Proxy.newProxyInstance(</span><br><span class="line">					classLoader,</span><br><span class="line">					new Class&lt;?&gt;[]&#123;clazz&#125;,</span><br><span class="line">					invocationHandler);</span><br><span class="line">				return proxy;</span><br><span class="line">			&#125;,</span><br><span class="line">			actorSystem.dispatcher());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>连接请求也比较简单, 每次RPC调用时, 都使用ask:</p>
<ol>
<li>向ResourceManager发送Identify, 远程响应并发返回对应路径的角色</li>
<li>向ResourceManager发送RemoteHandshakeMessage, 再次和远程确认。</li>
<li>以上两个RPC调用完成后, 构建针对ResourceManagerGateway的代理, 其中handler为FencedAkkaInvocationHandler(rpcEndpoint&#x3D;ActorRef)。</li>
</ol>
<h2 id="TM向JM远程RPC注册"><a href="#TM向JM远程RPC注册" class="headerlink" title="TM向JM远程RPC注册"></a>TM向JM远程RPC注册</h2><p>当获取到通信的ActorRef后, 调用register进行注册:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   private void register(final G gateway, final int attempt, final long timeoutMillis) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">	    // 跑到ResourceManagerConnection.invokeRegistration</span><br><span class="line">		log.info(&quot;Registration at &#123;&#125; attempt &#123;&#125; (timeout=&#123;&#125;ms)&quot;, targetName, attempt, timeoutMillis);</span><br><span class="line">		CompletableFuture&lt;RegistrationResponse&gt; registrationFuture = invokeRegistration(gateway, fencingToken, timeoutMillis);</span><br><span class="line">		// if the registration was successful, let the TaskExecutor know</span><br><span class="line">		CompletableFuture&lt;Void&gt; registrationAcceptFuture = registrationFuture.thenAcceptAsync(</span><br><span class="line">			(RegistrationResponse result) -&gt; &#123;</span><br><span class="line">				if (!isCanceled()) &#123;</span><br><span class="line">					if (result instanceof RegistrationResponse.Success) &#123;</span><br><span class="line">						// registration successful!</span><br><span class="line">						S success = (S) result;  // JobMasterRegistrationSuccess</span><br><span class="line">						//表示完成了JobMaster的注册，将completionFuture置为完成</span><br><span class="line">						completionFuture.complete(Tuple2.of(gateway, success));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			rpcService.getExecutor());</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable t) &#123;</span><br><span class="line">		completionFuture.completeExceptionally(t);</span><br><span class="line">		cancel();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到:</p>
<ol>
<li>register中真正向ResourceManager通信的是invokeRegistration()。</li>
<li>将completionFuture置为完成, 那么将触发之前定义的TaskExecutorToResourceManagerConnection.onRegistrationSuccess()。<br>我们先看invokeRegistration的实现逻辑:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">      protected CompletableFuture&lt;RegistrationResponse&gt; invokeRegistration(</span><br><span class="line">		ResourceManagerGateway resourceManager, ResourceManagerId fencingToken, long timeoutMillis) throws Exception &#123;</span><br><span class="line">	Time timeout = Time.milliseconds(timeoutMillis);</span><br><span class="line">	//resourceManager=FencedAkkaInvocationHandler,返回TaskExecutorRegistrationSuccess， 这里会跳到JobManager</span><br><span class="line">	return resourceManager.registerTaskExecutor(</span><br><span class="line">		taskExecutorAddress,</span><br><span class="line">		resourceID,</span><br><span class="line">		dataPort,</span><br><span class="line">		hardwareDescription,</span><br><span class="line">		timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>resourceManager.registerTaskExecutor将首先跑到FencedAkkaInvocationHandler.invoke, 最终真正发送rpc请求的是invokeRpc:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private Object invokeRpc(Method method, Object[] args) throws Exception &#123;</span><br><span class="line">	String methodName = method.getName();</span><br><span class="line">	Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">	Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class="line">	Time futureTimeout = extractRpcTimeout(parameterAnnotations, args, timeout);</span><br><span class="line">	//这里会构建函数名称等</span><br><span class="line">	final RpcInvocation rpcInvocation = createRpcInvocationMessage(methodName, parameterTypes, args);</span><br><span class="line">	Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">	final Object result;</span><br><span class="line">	if (Objects.equals(returnType, Void.TYPE)) &#123;</span><br><span class="line">		tell(rpcInvocation);</span><br><span class="line">		result = null;</span><br><span class="line">	&#125; else if (Objects.equals(returnType, CompletableFuture.class)) &#123;</span><br><span class="line">		// execute an asynchronous call, 需要返回请求结果。</span><br><span class="line">		result = ask(rpcInvocation, futureTimeout);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// execute a synchronous call</span><br><span class="line">		CompletableFuture&lt;?&gt; futureResult = ask(rpcInvocation, futureTimeout);</span><br><span class="line">		result = futureResult.get(futureTimeout.getSize(), futureTimeout.getUnit());</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终通过ask将请求发送出去, 其中包括函数名, 参数等信息。</p>
<h1 id="远程ResourceManager接收到请求"><a href="#远程ResourceManager接收到请求" class="headerlink" title="远程ResourceManager接收到请求"></a>远程ResourceManager接收到请求</h1><p>我们可以看到在构建YarnResourceManager时, resourceManagerEndpointId为<code>resourcemanager</code>, 最终其ActorRef对应的直接地址为: akka.tcp:&#x2F;&#x2F;flink@jobmanager:port&#x2F;user&#x2F;resourcemanager, 印证了之前TM向JM注册时, JM通信的终端就是该类。在ActorRef构建过程中, 知道JM接受处理类为AkkaRpcActor.onReceive(FencedAkkaRpcActor父类), 继续调用的是handleRpcMessage()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void handleRpcMessage(Object message) &#123;</span><br><span class="line">	if (message instanceof RunAsync) &#123;</span><br><span class="line">		handleRunAsync((RunAsync) message);</span><br><span class="line">	&#125; else if (message instanceof CallAsync) &#123;</span><br><span class="line">		handleCallAsync((CallAsync) message);</span><br><span class="line">	&#125; else if (message instanceof RpcInvocation) &#123;</span><br><span class="line">		handleRpcInvocation((RpcInvocation) message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flink针对不同类型的消息, 使用调用的函数, 很显然, 这里调用handleRpcInvocation:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private void handleRpcInvocation(RpcInvocation rpcInvocation) &#123;</span><br><span class="line">	Method rpcMethod = null;</span><br><span class="line">	try &#123;</span><br><span class="line">		String methodName = rpcInvocation.getMethodName();</span><br><span class="line">		Class&lt;?&gt;[] parameterTypes = rpcInvocation.getParameterTypes();</span><br><span class="line">		rpcMethod = lookupRpcMethod(methodName, parameterTypes);</span><br><span class="line">	&#125;</span><br><span class="line">	if (rpcMethod != null) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			// this supports declaration of anonymous classes</span><br><span class="line">			rpcMethod.setAccessible(true);</span><br><span class="line">			if (rpcMethod.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">				// No return value to send back</span><br><span class="line">				rpcMethod.invoke(rpcEndpoint, rpcInvocation.getArgs());</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				final Object result;</span><br><span class="line">				try &#123;</span><br><span class="line">					result = rpcMethod.invoke(rpcEndpoint, rpcInvocation.getArgs());</span><br><span class="line">				&#125;</span><br><span class="line">				if (result instanceof CompletableFuture) &#123;</span><br><span class="line">					final CompletableFuture&lt;?&gt; future = (CompletableFuture&lt;?&gt;) result;</span><br><span class="line">					Promise.DefaultPromise&lt;Object&gt; promise = new Promise.DefaultPromise&lt;&gt;();</span><br><span class="line"></span><br><span class="line">					future.whenComplete(</span><br><span class="line">						(value, throwable) -&gt; &#123;</span><br><span class="line">							if (throwable != null) &#123;</span><br><span class="line">								promise.failure(throwable);</span><br><span class="line">							&#125; else &#123;</span><br><span class="line">							    //再回调一下</span><br><span class="line">								promise.success(value);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line"></span><br><span class="line">					Patterns.pipe(promise.future(), getContext().dispatcher()).to(getSender());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用的是result &#x3D; rpcMethod.invoke()来处理TM发送的请求。实际调用ResourceManager.registerTaskExecutor()-&gt;registerTaskExecutorInternal()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private RegistrationResponse registerTaskExecutorInternal(</span><br><span class="line">		TaskExecutorGateway taskExecutorGateway,</span><br><span class="line">		String taskExecutorAddress,</span><br><span class="line">		ResourceID taskExecutorResourceId,</span><br><span class="line">		int dataPort,</span><br><span class="line">		HardwareDescription hardwareDescription) &#123;</span><br><span class="line">	WorkerRegistration&lt;WorkerType&gt; oldRegistration = taskExecutors.remove(taskExecutorResourceId);</span><br><span class="line">	// 首先做些清理, 删掉旧的</span><br><span class="line">	if (oldRegistration != null) &#123;</span><br><span class="line">		// TODO :: suggest old taskExecutor to stop itself</span><br><span class="line">		log.debug(&quot;Replacing old registration of TaskExecutor &#123;&#125;.&quot;, taskExecutorResourceId);</span><br><span class="line">		// remove old task manager registration from slot manager</span><br><span class="line">		slotManager.unregisterTaskManager(oldRegistration.getInstanceID());</span><br><span class="line">	&#125;</span><br><span class="line">       // 跑到YarnResourceManager.workerStarted(在yarn返回container成功后，会去注册Container)</span><br><span class="line">	final WorkerType newWorker = workerStarted(taskExecutorResourceId);</span><br><span class="line">	if (newWorker == null) &#123;</span><br><span class="line">	    //找不到, 就说明这个container不是这个JM申请的</span><br><span class="line">		log.warn(&quot;Discard registration from TaskExecutor &#123;&#125; at (&#123;&#125;) because the framework did &quot; +</span><br><span class="line">			&quot;not recognize it&quot;, taskExecutorResourceId, taskExecutorAddress);</span><br><span class="line">		return new RegistrationResponse.Decline(&quot;unrecognized TaskExecutor&quot;);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		WorkerRegistration&lt;WorkerType&gt; registration =</span><br><span class="line">		    //taskExecutorGateway=AkkaInvocationHandler，  newWorker = YarnWorkerNode</span><br><span class="line">			new WorkerRegistration&lt;&gt;(taskExecutorGateway, newWorker, dataPort, hardwareDescription);</span><br><span class="line">		// 统计活跃而Container。</span><br><span class="line">		taskExecutors.put(taskExecutorResourceId, registration);</span><br><span class="line">		taskManagerHeartbeatManager.monitorTarget(taskExecutorResourceId, new HeartbeatTarget&lt;Void&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void receiveHeartbeat(ResourceID resourceID, Void payload) &#123;</span><br><span class="line">				// the ResourceManager will always send heartbeat requests to the</span><br><span class="line">				// TaskManager</span><br><span class="line">			&#125;</span><br><span class="line">			@Override</span><br><span class="line">			public void requestHeartbeat(ResourceID resourceID, Void payload) &#123;</span><br><span class="line">				taskExecutorGateway.heartbeatFromResourceManager(resourceID);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		return new TaskExecutorRegistrationSuccess(</span><br><span class="line">			registration.getInstanceID(),</span><br><span class="line">			resourceId,</span><br><span class="line">			resourceManagerConfiguration.getHeartbeatInterval().toMilliseconds(),</span><br><span class="line">			clusterInformation);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ResourceManager注册主要做了如下事情:</p>
<ol>
<li>从taskExecutors中删除旧的通信管道。</li>
<li>跑到YarnResourceManager.workerStarted()里面, 从JM端根据获取当初yarn分配的Container。</li>
<li>向taskExecutors添加新产生的管道WorkerRegistration。管道里包含TaskExecutorGateway的代理, 其中handler为AkkaInvocationHandler, 且包含连接JobManager的ActorRef。</li>
<li>JM对连接的TM添加监控。然后响应TM。</li>
</ol>
<h1 id="TM接收到JM响应"><a href="#TM接收到JM响应" class="headerlink" title="TM接收到JM响应"></a>TM接收到JM响应</h1><p>当TM接收到JM响应, 就会回调之前定义的TaskExecutorToResourceManagerConnection.onRegistrationSuccess()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void establishResourceManagerConnection(</span><br><span class="line">		ResourceManagerGateway resourceManagerGateway,</span><br><span class="line">		ResourceID resourceManagerResourceId,</span><br><span class="line">		InstanceID taskExecutorRegistrationId,</span><br><span class="line">		ClusterInformation clusterInformation) &#123;</span><br><span class="line">	// TM向JM会报本地slot的情况, 供JM来分配给申请者。</span><br><span class="line">	final CompletableFuture&lt;Acknowledge&gt; slotReportResponseFuture = resourceManagerGateway.sendSlotReport(</span><br><span class="line">		getResourceID(),</span><br><span class="line">		taskExecutorRegistrationId,</span><br><span class="line">		taskSlotTable.createSlotReport(getResourceID()),</span><br><span class="line">		taskManagerConfiguration.getTimeout());</span><br><span class="line">	// monitor the resource manager as heartbeat target</span><br><span class="line">	resourceManagerHeartbeatManager.monitorTarget(resourceManagerResourceId, new HeartbeatTarget&lt;SlotReport&gt;() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void receiveHeartbeat(ResourceID resourceID, SlotReport slotReport) &#123;</span><br><span class="line">			resourceManagerGateway.heartbeatFromTaskManager(resourceID, slotReport);</span><br><span class="line">		&#125;</span><br><span class="line">		@Override</span><br><span class="line">		public void requestHeartbeat(ResourceID resourceID, SlotReport slotReport) &#123;</span><br><span class="line">			// the TaskManager won&apos;t send heartbeat requests to the ResourceManager</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	// set the propagated blob server address</span><br><span class="line">	final InetSocketAddress blobServerAddress = new InetSocketAddress(</span><br><span class="line">		clusterInformation.getBlobServerHostname(),</span><br><span class="line">		clusterInformation.getBlobServerPort());</span><br><span class="line">	blobCacheService.setBlobServerAddress(blobServerAddress);</span><br><span class="line">	establishedResourceManagerConnection = new EstablishedResourceManagerConnection(</span><br><span class="line">		resourceManagerGateway,</span><br><span class="line">		resourceManagerResourceId,</span><br><span class="line">		taskExecutorRegistrationId);</span><br><span class="line">	stopRegistrationTimeout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TM当收到Response, 回调函数做了如下事情:</p>
<ol>
<li>通过resourceManagerGateway.sendSlotReport向YarnResourceManager汇报当前TM可用slot, 可用slot都将保存在 JobManager ResourceManager.freeSlots里面。</li>
<li>开始向ResourceManager上报心跳。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到, Akka通信最底层依靠的是Patterns.ask来完成, 整个通信流程也是比较清晰的。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/elasticsearch_learning/categories/Flink//" class="article-tag-list-link color1">Flink</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/elasticsearch_learning/2019/04/20/Flink原理-Akka通信模块/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Flink原理-TaskManager处理SubTask" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/elasticsearch_learning/2019/04/03/Flink原理-TaskManager处理SubTask/">Flink原理-TaskManager处理SubTask</a>
    </h1>
  

        
        <a href="/elasticsearch_learning/2019/04/03/Flink原理-TaskManager处理SubTask/" class="archive-article-date">
  	<time datetime="2019-04-03T04:10:04.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-04-03</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在了解TaskManager处理task之前, 我们先看下该JVM启动过程。 TaskManager端yarn启动的类为YarnTaskExecutorRunner, TM端存放当前可利用的slot信息存放在TaskManagerServices.taskSlotTable里面, slot默认资源为new ResourceProfile(cpu&#x3D;1.0, men&#x3D;42)。<br>在<a href="https://kkewwei.github.io/elasticsearch_learning/2019/03/12/Flink%E5%8E%9F%E7%90%86-slot%E5%88%86%E9%85%8D/#%E9%83%A8%E7%BD%B2subTask%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84slot">Flink原理-Slot申请及SubTask部署</a>中, 我们知道, subTask会在JobManager中通过TaskManagerGateway.submitTask(deployment, rpcTimeout)进行部署subTask。TaskManager会通过TaskExecutor.subTask()接收到该部署请求。</p>
<figure class="highlight plain"><figcaption><span>CompletableFuture<acknowledge> submitTask(</acknowledge></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">		TaskDeploymentDescriptor tdd,</span><br><span class="line">		JobMasterId jobMasterId,</span><br><span class="line">		Time timeout) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		final JobID jobId = tdd.getJobId();</span><br><span class="line">		//获得与jobManager通信的链接</span><br><span class="line">		final JobManagerConnection jobManagerConnection = jobManagerTable.get(jobId);</span><br><span class="line">		// re-integrate offloaded data:</span><br><span class="line">		try &#123;</span><br><span class="line">			tdd.loadBigData(blobCacheService.getPermanentBlobService()); //啥事不做</span><br><span class="line">		&#125; catch (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">			throw new TaskSubmissionException(&quot;Could not re-integrate offloaded TaskDeploymentDescriptor data.&quot;, e);</span><br><span class="line">		&#125;</span><br><span class="line">		// deserialize the pre-serialized information</span><br><span class="line">		final JobInformation jobInformation;</span><br><span class="line">		final TaskInformation taskInformation;</span><br><span class="line">		try &#123;</span><br><span class="line">			jobInformation = tdd.getSerializedJobInformation().deserializeValue(getClass().getClassLoader());</span><br><span class="line">			taskInformation = tdd.getSerializedTaskInformation().deserializeValue(getClass().getClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		Task task = new Task(</span><br><span class="line">			jobInformation,</span><br><span class="line">			taskInformation,</span><br><span class="line">			tdd.getExecutionAttemptId(),</span><br><span class="line">			tdd.getAllocationId(),</span><br><span class="line">			tdd.getSubtaskIndex(),</span><br><span class="line">			tdd.getAttemptNumber(),</span><br><span class="line">			tdd.getProducedPartitions(),</span><br><span class="line">			tdd.getInputGates(),</span><br><span class="line">			tdd.getTargetSlotNumber(),</span><br><span class="line">			taskExecutorServices.getMemoryManager(),</span><br><span class="line">			taskExecutorServices.getIOManager(),</span><br><span class="line">			taskExecutorServices.getNetworkEnvironment(),</span><br><span class="line">			taskExecutorServices.getBroadcastVariableManager(),</span><br><span class="line">			taskStateManager,</span><br><span class="line">			taskManagerActions,</span><br><span class="line">			inputSplitProvider,</span><br><span class="line">			checkpointResponder,</span><br><span class="line">			blobCacheService,</span><br><span class="line">			libraryCache,</span><br><span class="line">			fileCache,</span><br><span class="line">			taskManagerConfiguration,</span><br><span class="line">			taskMetricGroup,</span><br><span class="line">			resultPartitionConsumableNotifier,</span><br><span class="line">			partitionStateChecker,</span><br><span class="line">			getRpcService().getExecutor());</span><br><span class="line">		log.info(&quot;Received task &#123;&#125;.&quot;, task.getTaskInfo().getTaskNameWithSubtasks());</span><br><span class="line">		boolean taskAdded;</span><br><span class="line">		try &#123;</span><br><span class="line">		    // 将task放入taskSlotTable.taskSlotMappings中</span><br><span class="line">			taskAdded = taskSlotTable.addTask(task);</span><br><span class="line">		&#125;</span><br><span class="line">		if (taskAdded) &#123;</span><br><span class="line">		    //这里比较重要，开始进行task执行</span><br><span class="line">			task.startTaskThread();</span><br><span class="line">			return CompletableFuture.completedFuture(Acknowledge.get());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TM接收到请求后, 首先构建Task(Runnable), 然后通过task.startTaskThread()将这个线程运行起来, 真正执行任务的是run函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line"></span><br><span class="line">		// ----------------------------</span><br><span class="line">		//  Initial State transition</span><br><span class="line">		// ----------------------------</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			ExecutionState current = this.executionState;</span><br><span class="line">			// 首先将Task状态置为DEPLOYING状态, 状态不修改成功, 不停地尝试</span><br><span class="line">			if (current == ExecutionState.CREATED) &#123;</span><br><span class="line">				if (transitionState(ExecutionState.CREATED, ExecutionState.DEPLOYING)) &#123;</span><br><span class="line">					// success, we can start our work</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (current == ExecutionState.FAILED) &#123;</span><br><span class="line">				// we were immediately failed. tell the TaskManager that we reached our final state</span><br><span class="line">				notifyFinalState();</span><br><span class="line">				if (metrics != null) &#123;</span><br><span class="line">					metrics.close();</span><br><span class="line">				&#125;</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (current == ExecutionState.CANCELING) &#123;</span><br><span class="line">				if (transitionState(ExecutionState.CANCELING, ExecutionState.CANCELED)) &#123;</span><br><span class="line">					// we were immediately canceled. tell the TaskManager that we reached our final state</span><br><span class="line">					notifyFinalState();</span><br><span class="line">					if (metrics != null) &#123;</span><br><span class="line">						metrics.close();</span><br><span class="line">					&#125;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// all resource acquisitions and registrations from here on</span><br><span class="line">		// need to be undone in the end</span><br><span class="line">		Map&lt;String, Future&lt;Path&gt;&gt; distributedCacheEntries = new HashMap&lt;&gt;();</span><br><span class="line">		AbstractInvokable invokable = null;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// ----------------------------</span><br><span class="line">			//  Task Bootstrap - We periodically</span><br><span class="line">			//  check for canceling as a shortcut</span><br><span class="line">			// ----------------------------</span><br><span class="line"></span><br><span class="line">			// activate safety net for task thread</span><br><span class="line">			LOG.info(&quot;Creating FileSystem stream leak safety net for task &#123;&#125;&quot;, this);</span><br><span class="line">			FileSystemSafetyNet.initializeSafetyNetForThread();</span><br><span class="line"></span><br><span class="line">			blobService.getPermanentBlobService().registerJob(jobId);</span><br><span class="line"></span><br><span class="line">			// first of all, get a user-code classloader</span><br><span class="line">			// this may involve downloading the job&apos;s JAR files and/or classes</span><br><span class="line">			LOG.info(&quot;Loading JAR files for task &#123;&#125;.&quot;, this);</span><br><span class="line"></span><br><span class="line">			userCodeClassLoader = createUserCodeClassloader();</span><br><span class="line">			final ExecutionConfig executionConfig = serializedExecutionConfig.deserializeValue(userCodeClassLoader);</span><br><span class="line"></span><br><span class="line">			if (executionConfig.getTaskCancellationInterval() &gt;= 0) &#123;</span><br><span class="line">				// override task cancellation interval from Flink config if set in ExecutionConfig</span><br><span class="line">				taskCancellationInterval = executionConfig.getTaskCancellationInterval();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (executionConfig.getTaskCancellationTimeout() &gt;= 0) &#123;</span><br><span class="line">				// override task cancellation timeout from Flink config if set in ExecutionConfig</span><br><span class="line">				taskCancellationTimeout = executionConfig.getTaskCancellationTimeout();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (isCanceledOrFailed()) &#123;</span><br><span class="line">				throw new CancelTaskException();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// ----------------------------------------------------------------</span><br><span class="line">			// register the task with the network stack</span><br><span class="line">			// this operation may fail if the system does not have enough</span><br><span class="line">			// memory to run the necessary data exchanges</span><br><span class="line">			// the registration must also strictly be undone</span><br><span class="line">			// ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">			LOG.info(&quot;Registering task at network: &#123;&#125;.&quot;, this);</span><br><span class="line"></span><br><span class="line">			network.registerTask(this);</span><br><span class="line"></span><br><span class="line">			// add metrics for buffers</span><br><span class="line">			this.metrics.getIOMetricGroup().initializeBufferMetrics(this);</span><br><span class="line"></span><br><span class="line">			// register detailed network metrics, if configured</span><br><span class="line">			if (taskManagerConfig.getConfiguration().getBoolean(TaskManagerOptions.NETWORK_DETAILED_METRICS)) &#123;</span><br><span class="line">				// similar to MetricUtils.instantiateNetworkMetrics() but inside this IOMetricGroup</span><br><span class="line">				MetricGroup networkGroup = this.metrics.getIOMetricGroup().addGroup(&quot;Network&quot;);</span><br><span class="line">				MetricGroup outputGroup = networkGroup.addGroup(&quot;Output&quot;);</span><br><span class="line">				MetricGroup inputGroup = networkGroup.addGroup(&quot;Input&quot;);</span><br><span class="line"></span><br><span class="line">				// output metrics</span><br><span class="line">				for (int i = 0; i &lt; producedPartitions.length; i++) &#123;</span><br><span class="line">					ResultPartitionMetrics.registerQueueLengthMetrics(</span><br><span class="line">						outputGroup.addGroup(i), producedPartitions[i]);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				for (int i = 0; i &lt; inputGates.length; i++) &#123;</span><br><span class="line">					InputGateMetrics.registerQueueLengthMetrics(</span><br><span class="line">						inputGroup.addGroup(i), inputGates[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// next, kick off the background copying of files for the distributed cache</span><br><span class="line">			try &#123;</span><br><span class="line">				for (Map.Entry&lt;String, DistributedCache.DistributedCacheEntry&gt; entry :</span><br><span class="line">						DistributedCache.readFileInfoFromConfig(jobConfiguration)) &#123;</span><br><span class="line">					LOG.info(&quot;Obtaining local cache file for &apos;&#123;&#125;&apos;.&quot;, entry.getKey());</span><br><span class="line">					Future&lt;Path&gt; cp = fileCache.createTmpFile(entry.getKey(), entry.getValue(), jobId, executionId);</span><br><span class="line">					distributedCacheEntries.put(entry.getKey(), cp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (isCanceledOrFailed()) &#123;</span><br><span class="line">				throw new CancelTaskException();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// ----------------------------------------------------------------</span><br><span class="line">			//  call the user code initialization methods</span><br><span class="line">			// ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">			TaskKvStateRegistry kvStateRegistry = network.createKvStateTaskRegistry(jobId, getJobVertexId());</span><br><span class="line"></span><br><span class="line">			Environment env = new RuntimeEnvironment(</span><br><span class="line">				jobId,</span><br><span class="line">				vertexId,</span><br><span class="line">				executionId,</span><br><span class="line">				executionConfig,</span><br><span class="line">				taskInfo,</span><br><span class="line">				jobConfiguration,</span><br><span class="line">				taskConfiguration,</span><br><span class="line">				userCodeClassLoader,</span><br><span class="line">				memoryManager,</span><br><span class="line">				ioManager,</span><br><span class="line">				broadcastVariableManager,</span><br><span class="line">				taskStateManager,</span><br><span class="line">				accumulatorRegistry,</span><br><span class="line">				kvStateRegistry,</span><br><span class="line">				inputSplitProvider,</span><br><span class="line">				distributedCacheEntries,</span><br><span class="line">				producedPartitions,</span><br><span class="line">				inputGates,</span><br><span class="line">				network.getTaskEventDispatcher(),</span><br><span class="line">				checkpointResponder,</span><br><span class="line">				taskManagerConfig,</span><br><span class="line">				metrics,</span><br><span class="line">				this);</span><br><span class="line">            // 加载用户Task, 比如SourceStreamTask(Source: Custom Source (2/2))</span><br><span class="line">			// now load and instantiate the task&apos;s invokable code</span><br><span class="line">			invokable = loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass, env);</span><br><span class="line"></span><br><span class="line">			// ----------------------------------------------------------------</span><br><span class="line">			//  actual task core work</span><br><span class="line">			// ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">			// we must make strictly sure that the invokable is accessible to the cancel() call</span><br><span class="line">			// by the time we switched to running.</span><br><span class="line">			this.invokable = invokable;</span><br><span class="line"></span><br><span class="line">			// switch to the RUNNING state, if that fails, we have been canceled/failed in the meantime</span><br><span class="line">			if (!transitionState(ExecutionState.DEPLOYING, ExecutionState.RUNNING)) &#123;</span><br><span class="line">				throw new CancelTaskException();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// notify everyone that we switched to running</span><br><span class="line">			notifyObservers(ExecutionState.RUNNING, null);</span><br><span class="line">			taskManagerActions.updateTaskExecutionState(new TaskExecutionState(jobId, executionId, ExecutionState.RUNNING));</span><br><span class="line"></span><br><span class="line">			// make sure the user code classloader is accessible thread-locally</span><br><span class="line">			executingThread.setContextClassLoader(userCodeClassLoader);</span><br><span class="line">            // 真正开始执行这个task。</span><br><span class="line">			// run the invokable</span><br><span class="line">			invokable.invoke();</span><br><span class="line"></span><br><span class="line">			// make sure, we enter the catch block if the task leaves the invoke() method due</span><br><span class="line">			// to the fact that it has been canceled</span><br><span class="line">			if (isCanceledOrFailed()) &#123;</span><br><span class="line">				throw new CancelTaskException();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// ----------------------------------------------------------------</span><br><span class="line">			//  finalization of a successful execution</span><br><span class="line">			// ----------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">			// finish the produced partitions. if this fails, we consider the execution failed.</span><br><span class="line">			for (ResultPartition partition : producedPartitions) &#123;</span><br><span class="line">				if (partition != null) &#123;</span><br><span class="line">					partition.finish();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// try to mark the task as finished</span><br><span class="line">			// if that fails, the task was canceled/failed in the meantime</span><br><span class="line">			if (transitionState(ExecutionState.RUNNING, ExecutionState.FINISHED)) &#123;</span><br><span class="line">				notifyObservers(ExecutionState.FINISHED, null);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				throw new CancelTaskException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				LOG.info(&quot;Freeing task resources for &#123;&#125; (&#123;&#125;).&quot;, taskNameWithSubtask, executionId);</span><br><span class="line"></span><br><span class="line">				// clear the reference to the invokable. this helps guard against holding references</span><br><span class="line">				// to the invokable and its structures in cases where this Task object is still referenced</span><br><span class="line">				this.invokable = null;</span><br><span class="line"></span><br><span class="line">				// stop the async dispatcher.</span><br><span class="line">				// copy dispatcher reference to stack, against concurrent release</span><br><span class="line">				ExecutorService dispatcher = this.asyncCallDispatcher;</span><br><span class="line">				if (dispatcher != null &amp;&amp; !dispatcher.isShutdown()) &#123;</span><br><span class="line">					dispatcher.shutdownNow();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// free the network resources</span><br><span class="line">				network.unregisterTask(this);</span><br><span class="line"></span><br><span class="line">				// free memory resources</span><br><span class="line">				if (invokable != null) &#123;</span><br><span class="line">					memoryManager.releaseAll(invokable);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// remove all of the tasks library resources</span><br><span class="line">				libraryCache.unregisterTask(jobId, executionId);</span><br><span class="line">				fileCache.releaseJob(jobId, executionId);</span><br><span class="line">				blobService.getPermanentBlobService().releaseJob(jobId);</span><br><span class="line"></span><br><span class="line">				// close and de-activate safety net for task thread</span><br><span class="line">				LOG.info(&quot;Ensuring all FileSystem streams are closed for task &#123;&#125;&quot;, this);</span><br><span class="line">				FileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread();</span><br><span class="line"></span><br><span class="line">				notifyFinalState();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要做了如下事情:</p>
<ol>
<li>加载jar, 配置文件。</li>
<li>确认invoke函数, invoke函数在JobVertex产生的时候构建的, 比如在StreamingJobGraphGenerator.createJobVertex()中, 而这个invoke最初是在产生StreamNode时候赋值的, 比如在StreamingJobGraphGenerator.transform-&gt;transformOneInputTransform-&gt;StreamGraph.addOperator:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public &lt;IN, OUT&gt; void addOperator(</span><br><span class="line">			Integer vertexID,</span><br><span class="line">			String slotSharingGroup,</span><br><span class="line">			@Nullable String coLocationGroup,</span><br><span class="line">			StreamOperator&lt;OUT&gt; operatorObject,</span><br><span class="line">			TypeInformation&lt;IN&gt; inTypeInfo,</span><br><span class="line">			TypeInformation&lt;OUT&gt; outTypeInfo,</span><br><span class="line">			String operatorName) &#123;</span><br><span class="line"></span><br><span class="line">		if (operatorObject instanceof StoppableStreamSource) &#123;</span><br><span class="line">			addNode(vertexID, slotSharingGroup, coLocationGroup, StoppableSourceStreamTask.class, operatorObject, operatorName);</span><br><span class="line">		&#125; else if (operatorObject instanceof StreamSource) &#123;</span><br><span class="line">			addNode(vertexID, slotSharingGroup, coLocationGroup, SourceStreamTask.class, operatorObject, operatorName);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			addNode(vertexID, slotSharingGroup, coLocationGroup, OneInputStreamTask.class, operatorObject, operatorName);</span><br><span class="line">		&#125;</span><br><span class="line">		......</span><br></pre></td></tr></table></figure></li>
</ol>
<p>可以看到, invoke可以为SourceStreamTask.class或者 OneInputStreamTask.class。 我们以最常见的OneInputStreamTask.class继续讲解。invokable.invoke()最终将跑到OneInputStreamTask.run里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void run() throws Exception &#123;</span><br><span class="line">	// cache processor reference on the stack, to make the code more JIT friendly</span><br><span class="line">	final StreamInputProcessor&lt;IN&gt; inputProcessor = this.inputProcessor;</span><br><span class="line"></span><br><span class="line">	while (running &amp;&amp; inputProcessor.processInput()) &#123;</span><br><span class="line">		// all the work happens in the &quot;processInput&quot; method</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, 每条数据就循环处理一次, 我们看下每条数据是如何处理的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">   public boolean processInput() throws Exception &#123;</span><br><span class="line">	if (isFinished) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	if (numRecordsIn == null) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			numRecordsIn = ((OperatorMetricGroup) streamOperator.getMetricGroup()).getIOMetricGroup().getNumRecordsInCounter();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			LOG.warn(&quot;An exception occurred during the metrics setup.&quot;, e);</span><br><span class="line">			numRecordsIn = new SimpleCounter();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">      //这个while是用来处理单个元素的（不要想当然以为是循环处理元素的）</span><br><span class="line">	while (true) &#123;            //2.会利用这个反序列化器得到下一个数据记录，并进行解析（是用户数据还是watermark等等），然后进行对应的操作</span><br><span class="line">		if (currentRecordDeserializer != null) &#123;</span><br><span class="line">			DeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate); //得到下一条数据</span><br><span class="line"></span><br><span class="line">			if (result.isBufferConsumed()) &#123;</span><br><span class="line">				currentRecordDeserializer.getCurrentBuffer().recycleBuffer();</span><br><span class="line">				currentRecordDeserializer = null;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (result.isFullRecord()) &#123;</span><br><span class="line">				StreamElement recordOrMark = deserializationDelegate.getInstance();</span><br><span class="line">				//如果元素是watermark，就准备更新当前channel的watermark值（并不是简单赋值，因为有乱序存在）</span><br><span class="line">				if (recordOrMark.isWatermark()) &#123;</span><br><span class="line">					// handle watermark</span><br><span class="line">					statusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), currentChannel);</span><br><span class="line">					continue;</span><br><span class="line">				//如果元素是status，就进行相应处理。可以看作是一个flag，标志着当前stream接下来即将没有元素输入（idle），或者当前即将由空闲状态转为有元素状态（active）。同时，StreamStatus还对如何处理watermark有影响。通过发送status，上游的operator可以很方便的通知下游当前的数据流的状态。</span><br><span class="line">				&#125; else if (recordOrMark.isStreamStatus()) &#123;</span><br><span class="line">					// handle stream status</span><br><span class="line">					statusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), currentChannel);</span><br><span class="line">					continue;</span><br><span class="line">				//LatencyMarker是用来衡量代码执行时间的。在Source处创建，携带创建时的时间戳，流到Sink时就可以知道经过了多长时间</span><br><span class="line">				&#125; else if (recordOrMark.isLatencyMarker()) &#123;</span><br><span class="line">					// handle latency marker</span><br><span class="line">					synchronized (lock) &#123;</span><br><span class="line">						streamOperator.processLatencyMarker(recordOrMark.asLatencyMarker());</span><br><span class="line">					&#125;</span><br><span class="line">					continue;</span><br><span class="line">				//这里就是真正的，用户的代码即将被执行的地方。</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					// now we can do the actual processing</span><br><span class="line">					StreamRecord&lt;IN&gt; record = recordOrMark.asRecord();</span><br><span class="line">					synchronized (lock) &#123;</span><br><span class="line">						numRecordsIn.inc();</span><br><span class="line">						streamOperator.setKeyContextElement1(record);</span><br><span class="line">						// 每个算子开始真正处理数据</span><br><span class="line">						streamOperator.processElement(record);</span><br><span class="line">					&#125;</span><br><span class="line">					return true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">           //1.程序首先获取下一个buffer，这一段代码是服务于flink的FaultTorrent机制的，后面我会讲到，这里只需理解到它会尝试获取buffer，然后赋值给当前的反序列化器</span><br><span class="line">		final BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked();</span><br><span class="line">		if (bufferOrEvent != null) &#123;</span><br><span class="line">			if (bufferOrEvent.isBuffer()) &#123;</span><br><span class="line">				currentChannel = bufferOrEvent.getChannelIndex();</span><br><span class="line">				currentRecordDeserializer = recordDeserializers[currentChannel];</span><br><span class="line">				currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// Event received</span><br><span class="line">				final AbstractEvent event = bufferOrEvent.getEvent();</span><br><span class="line">				if (event.getClass() != EndOfPartitionEvent.class) &#123;</span><br><span class="line">					throw new IOException(&quot;Unexpected event: &quot; + event);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			isFinished = true;</span><br><span class="line">			if (!barrierHandler.isEmpty()) &#123;</span><br><span class="line">				throw new IllegalStateException(&quot;Trailing data in checkpoint barrier handler.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每条数据都是通过streamOperator.processElement(record)来完成处理的, 以map算子为例, streamOperator为StreamMap:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> @Internal</span><br><span class="line">public class StreamMap&lt;IN, OUT&gt;</span><br><span class="line">		extends AbstractUdfStreamOperator&lt;OUT, MapFunction&lt;IN, OUT&gt;&gt;</span><br><span class="line">		implements OneInputStreamOperator&lt;IN, OUT&gt; &#123;</span><br><span class="line">	private static final long serialVersionUID = 1L;</span><br><span class="line">	public StreamMap(MapFunction&lt;IN, OUT&gt; mapper) &#123;</span><br><span class="line">		super(mapper);</span><br><span class="line">		chainingStrategy = ChainingStrategy.ALWAYS;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void processElement(StreamRecord&lt;IN&gt; element) throws Exception &#123;</span><br><span class="line">		output.collect(element.replace(userFunction.map(element.getValue())));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 可以看到, 我们只用负责定义map就可以了。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/elasticsearch_learning/categories/Flink//" class="article-tag-list-link color1">Flink</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/elasticsearch_learning/2019/04/03/Flink原理-TaskManager处理SubTask/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Flink原理-slot分配" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/elasticsearch_learning/2019/03/12/Flink原理-slot分配/">Flink原理-JobManager端的SubTask申请slot及部署</a>
    </h1>
  

        
        <a href="/elasticsearch_learning/2019/03/12/Flink原理-slot分配/" class="archive-article-date">
  	<time datetime="2019-03-12T12:04:11.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-03-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文将从ExecutionGraph开始向后讲起, ExecutionGraph定义了Job的并发逻辑结构, 作为任务执行的以后一层逻辑结构, 也是最核心数据结构。为了让大家有全局的了解, 先盗一张广为引用的Graph转换图:<br><img src="https://kkewwei.github.io/elasticsearch_learning/img/Flink_Graph.png" height="900" width="800"><br>具体来说, 本文讲述在JobManager端subTask申请slot以及部署到TaskManager上的过程。</p>
<h1 id="Task分配slot及部署"><a href="#Task分配slot及部署" class="headerlink" title="Task分配slot及部署"></a>Task分配slot及部署</h1><p>代码将从ExecutionGraph.scheduleExecutionGraph()开始讲解, 进入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void scheduleForExecution() throws JobException &#123;</span><br><span class="line">	final long currentGlobalModVersion = globalModVersion;</span><br><span class="line">	if (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) &#123;</span><br><span class="line">		final CompletableFuture&lt;Void&gt; newSchedulingFuture;</span><br><span class="line">		switch (scheduleMode) &#123;</span><br><span class="line">			case LAZY_FROM_SOURCES:</span><br><span class="line">				newSchedulingFuture = scheduleLazy(slotProvider);</span><br><span class="line">				break;</span><br><span class="line">			case EAGER:</span><br><span class="line">				newSchedulingFuture = scheduleEager(slotProvider, allocationTimeout);</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">				throw new JobException(&quot;Schedule mode is invalid.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中, scheduleMode分EAGER和LAZY_FROM_SOURCES, EAGER表示立刻去调度部署所有的Task。实际scheduleMode是从JobGraph.getScheduleMode()取值的, 为eager。<br>我们再进入scheduleEager看是如何调度task的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   private CompletableFuture&lt;Void&gt; scheduleEager(SlotProvider slotProvider, final Time timeout) &#123;</span><br><span class="line">    ......</span><br><span class="line">	 //都是每个JobGraph</span><br><span class="line">	for (ExecutionJobVertex ejv : getVerticesTopologically()) &#123;</span><br><span class="line">		// these calls are not blocking, they only return futures</span><br><span class="line">		Collection&lt;CompletableFuture&lt;Execution&gt;&gt; allocationFutures = ejv.allocateResourcesForAll(</span><br><span class="line">			slotProvider, // SlotPool$ProviderAndOwner</span><br><span class="line">			queued,</span><br><span class="line">			LocationPreferenceConstraint.ALL,</span><br><span class="line">			allPreviousAllocationIds,</span><br><span class="line">			timeout);</span><br><span class="line">		allAllocationFutures.addAll(allocationFutures);</span><br><span class="line">	&#125;</span><br><span class="line">	//只有当所有Execution都分配到了槽位才继续进行部署</span><br><span class="line">	final ConjunctFuture&lt;Collection&lt;Execution&gt;&gt; allAllocationsFuture = FutureUtils.combineAll(allAllocationFutures);</span><br><span class="line">	final CompletableFuture&lt;Void&gt; currentSchedulingFuture = allAllocationsFuture</span><br><span class="line">		.thenAccept(</span><br><span class="line">			(Collection&lt;Execution&gt; executionsToDeploy) -&gt; &#123;</span><br><span class="line">				for (Execution execution : executionsToDeploy) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">					   // 最后挨个调用execution.deploy()进行部署子task，部署的模式是发送命令到</span><br><span class="line">					   execution.deploy();</span><br><span class="line">					&#125; catch (Throwable t) &#123;</span><br><span class="line">					   ......</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		......</span><br><span class="line">	return currentSchedulingFuture;</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure>

<p>scheduleEager主要做了两件事:</p>
<ul>
<li>通过allocateResourcesForAll确定每个subTask将要部署的slot。若没有合适的TaskManager, 那么通过yarn去申请TaskManager。</li>
<li>当所有的subTask都确定好部署TaskManager的slot后, 通过execution.deploy()将subTask部署上去。<br>接下来, 将分别围绕这两件事讲解。<h2 id="确定subTask分配的slot"><a href="#确定subTask分配的slot" class="headerlink" title="确定subTask分配的slot"></a>确定subTask分配的slot</h2>通过getVerticesTopologically()获取所有的ExecutionJobVertex, 然后依次轮询给每个ExecutionJobVertex都分配一个slot, 其中轮询的ExecutionJobVertex是有先后顺序的, 从source开始分配slot, 直到sink。后面可以看到, 上游分配到哪个tm上, 会影响下游的slot分配。 我们进入allocateResourcesForAll看下是如何给一个ExecutionJobVertex所有的subTask分配slot的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   public Collection&lt;CompletableFuture&lt;Execution&gt;&gt; allocateResourcesForAll(</span><br><span class="line">		SlotProvider resourceProvider, // SlotPool$ProviderAndOwner</span><br><span class="line">		boolean queued,  //true</span><br><span class="line">		LocationPreferenceConstraint locationPreferenceConstraint, //ALL</span><br><span class="line">		@Nonnull Set&lt;AllocationID&gt; allPreviousExecutionGraphAllocationIds,</span><br><span class="line">		Time allocationTimeout) &#123;</span><br><span class="line">	final ExecutionVertex[] vertices = this.taskVertices;</span><br><span class="line">	final CompletableFuture&lt;Execution&gt;[] slots = new CompletableFuture[vertices.length];</span><br><span class="line">	for (int i = 0; i &lt; vertices.length; i++) &#123;</span><br><span class="line">		final Execution exec = vertices[i].getCurrentExecutionAttempt();</span><br><span class="line">		final CompletableFuture&lt;Execution&gt; allocationFuture = exec.allocateAndAssignSlotForExecution(</span><br><span class="line">			resourceProvider,</span><br><span class="line">			queued,</span><br><span class="line">			locationPreferenceConstraint,</span><br><span class="line">			allPreviousExecutionGraphAllocationIds,</span><br><span class="line">			allocationTimeout);</span><br><span class="line">		slots[i] = allocationFuture;</span><br><span class="line">	&#125;</span><br><span class="line">	return Arrays.asList(slots);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>每一个ExecutionJobVertex都对应着一批ExecutionVertex(也就是subTask), 可以看到, 这里轮询每个ExecutionVertex进行申请一个slot。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   public CompletableFuture&lt;Execution&gt; allocateAndAssignSlotForExecution(</span><br><span class="line">		SlotProvider slotProvider, //SlotPool$ProviderAndOwner</span><br><span class="line">		boolean queued,</span><br><span class="line">		LocationPreferenceConstraint locationPreferenceConstraint,  //ALL</span><br><span class="line">		@Nonnull Set&lt;AllocationID&gt; allPreviousExecutionGraphAllocationIds,</span><br><span class="line">		Time allocationTimeout) throws IllegalExecutionStateException &#123;</span><br><span class="line">	final SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup();</span><br><span class="line">	if (transitionState(CREATED, SCHEDULED)) &#123;</span><br><span class="line">	    // 默认情况下, 所有的subTask的共享组均为default</span><br><span class="line">		final SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null;</span><br><span class="line">		/** 获取subTask即将分配的&quot;偏好位置集合&quot;，也就是分配时，优先考虑分配在这些节点上，一般是input节点所在节点 */</span><br><span class="line">		final CompletableFuture&lt;Collection&lt;TaskManagerLocation&gt;&gt; preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint);</span><br><span class="line">	    //上游子task地方全部确定了，才能继续确定下游子task位置</span><br><span class="line">		final SlotRequestId slotRequestId = new SlotRequestId();</span><br><span class="line">		final CompletableFuture&lt;LogicalSlot&gt; logicalSlotFuture = preferredLocationsFuture</span><br><span class="line">			.thenCompose(</span><br><span class="line">				(Collection&lt;TaskManagerLocation&gt; preferredLocations) -&gt;</span><br><span class="line">					slotProvider.allocateSlot(//SlotPool$ProviderAndOwner</span><br><span class="line">						slotRequestId,</span><br><span class="line">						toSchedule,</span><br><span class="line">						queued,</span><br><span class="line">						new SlotProfile(</span><br><span class="line">							ResourceProfile.UNKNOWN,</span><br><span class="line">							preferredLocations,</span><br><span class="line">							previousAllocationIDs,</span><br><span class="line">							allPreviousExecutionGraphAllocationIds),</span><br><span class="line">						allocationTimeout));</span><br><span class="line">		return logicalSlotFuture.thenApply(</span><br><span class="line">			(LogicalSlot logicalSlot) -&gt; &#123;</span><br><span class="line">			    //</span><br><span class="line">				if (tryAssignResource(logicalSlot)) &#123;</span><br><span class="line">					return this;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数主要做了两件事情:</p>
<ul>
<li>在calculatePreferredLocations中确定从该subTask对应ExecutionJobVertex的所有上游中找到最合适的上游”偏向位置集合”。</li>
<li>通过SlotPool$ProviderAndOwner.allocateSlot继续确定从”偏向位置集合”找到一个共享slot。<br>我们知道, 多个subTask允许共享slot, 细节后面会详细描述。 那么当前subTask与哪些已经分配的subTask共享slot呢? 下游subTask与哪个上游subTask共享slot呢?<img src="https://kkewwei.github.io/elasticsearch_learning/img/Flink_slot_allocate.png" height="300" width="350"></li>
</ul>
<p>flink会根据subTask上游slot的分配来确定当前slot的分配:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public Collection&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; getPreferredLocationsBasedOnInputs() &#123;</span><br><span class="line">		// 如果没有输入，则返回空集合，否则，基于上游分布确定偏好位置</span><br><span class="line">		if (inputEdges == null) &#123;</span><br><span class="line">			return Collections.emptySet();</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			Set&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; locations = new HashSet&lt;&gt;(getTotalNumberOfParallelSubtasks());</span><br><span class="line">			Set&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; inputLocations = new HashSet&lt;&gt;(getTotalNumberOfParallelSubtasks());</span><br><span class="line">			// go over all inputs</span><br><span class="line">			for (int i = 0; i &lt; inputEdges.length; i++) &#123;</span><br><span class="line">				inputLocations.clear();</span><br><span class="line">				ExecutionEdge[] sources = inputEdges[i];</span><br><span class="line">				if (sources != null) &#123;</span><br><span class="line">					for (int k = 0; k &lt; sources.length; k++) &#123;</span><br><span class="line">						// 获取当前source源所属的taskManager位置</span><br><span class="line">						CompletableFuture&lt;TaskManagerLocation&gt; locationFuture = sources[k].getSource().getProducer().getCurrentTaskManagerLocationFuture();</span><br><span class="line">						// add input location</span><br><span class="line">						inputLocations.add(locationFuture);</span><br><span class="line">						// inputs which have too many distinct sources are not considered</span><br><span class="line">						// 如果某个输入源有太多的节点分布，则不考虑这个输入源的节点位置了</span><br><span class="line">						if (inputLocations.size() &gt; MAX_DISTINCT_LOCATIONS_TO_CONSIDER) &#123;</span><br><span class="line">							inputLocations.clear();</span><br><span class="line">							break;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;// 保留具有最少分布位置的输入的位置</span><br><span class="line">				// keep the locations of the input with the least preferred locations</span><br><span class="line">				if (locations.isEmpty() || // nothing assigned yet  第一个source</span><br><span class="line">				        // 找到上游节点所处tm最少的的那个上游</span><br><span class="line">						(!inputLocations.isEmpty() &amp;&amp; inputLocations.size() &lt; locations.size())) &#123;</span><br><span class="line">					locations.clear();</span><br><span class="line">					locations.addAll(inputLocations);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return locations.isEmpty() ? Collections.emptyList() : locations;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>处理过程如下:</p>
<ul>
<li>若该ExecutionVertex没有上游(例如source), 那么返回为空, 没有”偏好位置集合”, 之后将申请新的slot。</li>
<li>若当前ExecutionVertex有属于不同JobVertex多个ExecutionJobVertex的上游, 那么当前sub分配到哪些共享slot的可选路径只能是: 属于同一个JobVertex的上游节点个数最少。上图的话, 就会选择source2的所有subTask作为”偏好位置集合”。我们接下来看第二步, 最终会进入到allocateSharedSlot决定subTask分配到哪些”偏好位置集合”里slot上。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private CompletableFuture&lt;LogicalSlot&gt; allocateSharedSlot(</span><br><span class="line">		SlotRequestId slotRequestId,</span><br><span class="line">		ScheduledUnit task,</span><br><span class="line">		SlotProfile slotProfile,</span><br><span class="line">		boolean allowQueuedScheduling,</span><br><span class="line">		Time allocationTimeout) &#123;</span><br><span class="line">		// allocate slot with slot sharing</span><br><span class="line">		final SlotSharingManager multiTaskSlotManager = slotSharingManagers.computeIfAbsent(</span><br><span class="line">			 //默认都是一个, default对应的那个</span><br><span class="line">			task.getSlotSharingGroupId(),</span><br><span class="line">			id -&gt; new SlotSharingManager(</span><br><span class="line">				id,</span><br><span class="line">				this,</span><br><span class="line">				providerAndOwner));</span><br><span class="line">		final SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality;</span><br><span class="line">		try &#123;</span><br><span class="line">			if (task.getCoLocationConstraint() != null) &#123;</span><br><span class="line">				multiTaskSlotLocality = allocateCoLocatedMultiTaskSlot(</span><br><span class="line">					task.getCoLocationConstraint(),</span><br><span class="line">					multiTaskSlotManager,</span><br><span class="line">					slotProfile,</span><br><span class="line">					allowQueuedScheduling,</span><br><span class="line">					allocationTimeout);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">			     // 跑到这里</span><br><span class="line">				multiTaskSlotLocality = allocateMultiTaskSlot(</span><br><span class="line">					task.getJobVertexId(),</span><br><span class="line">					multiTaskSlotManager,</span><br><span class="line">					slotProfile,</span><br><span class="line">					allowQueuedScheduling,</span><br><span class="line">					allocationTimeout);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		final SlotSharingManager.SingleTaskSlot leaf = multiTaskSlotLocality.getMultiTaskSlot().allocateSingleTaskSlot(</span><br><span class="line">			slotRequestId,</span><br><span class="line">			task.getJobVertexId(),</span><br><span class="line">			multiTaskSlotLocality.getLocality());</span><br><span class="line">		return leaf.getLogicalSlotFuture();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>该函数主要做了两件事:</p>
<ol>
<li>通过allocateMultiTaskSlot产生MultiTaskSlotLocality, 里面包含从”偏向位置集合”中选取的部署当前subTask共享的slot。</li>
<li>产生SingleTaskSlot, 当前SingleTaskSlot作为MultiTaskSlot的一个子叶子节点。<br>再继续跟进代码前, 我们需要了解两个变量resolvedRootSlots、unresolvedRootSlots。共享slot都会从这两个变量中获取, 这两个变量为共享组所拥有, 默认共享组为default。<br>unresolvedRootSlots: 当当前subTask正在确认部署到那个slot中时, 会将该slot保存在unresolvedRootSlots; 当确定好部署到哪个slot时, 会将该信息从unresolvedRootSlots中移除, 并放入resolvedRootSlots中  当我们查找是否有可利用的slot时, 会从这些变量中查找。<br>我们再进入正题, 看allocateMultiTaskSlot看是如何给subTask分配slot的:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private SlotSharingManager.MultiTaskSlotLocality allocateMultiTaskSlot(</span><br><span class="line">		//groupId指的同一个JobVertex的id</span><br><span class="line">		AbstractID groupId,</span><br><span class="line">		SlotSharingManager slotSharingManager,</span><br><span class="line">		SlotProfile slotProfile,</span><br><span class="line">		boolean allowQueuedScheduling,</span><br><span class="line">		Time allocationTimeout) throws NoResourceAvailableException &#123;</span><br><span class="line">	//过滤&quot;偏好位置集合&quot;的位置中不属于相同groupId的位置, 这里主要是为了避免同一个ExecutionJobVertex中不同的SubTask分配到同一个slot中。</span><br><span class="line">	// check first whether we have a resolved root slot which we can use</span><br><span class="line">	SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality = slotSharingManager.getResolvedRootSlot(</span><br><span class="line">		groupId,</span><br><span class="line">		//  LocationPreferenceSchedulingStrategy</span><br><span class="line">		schedulingStrategy,</span><br><span class="line">		slotProfile);</span><br><span class="line">    //从&quot;偏好位置集合&quot;中到合适的slot后, 就直接返回了。</span><br><span class="line">	if (multiTaskSlotLocality != null &amp;&amp; multiTaskSlotLocality.getLocality() == Locality.LOCAL) &#123;</span><br><span class="line">		return multiTaskSlotLocality;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">	if (allowQueuedScheduling) &#123;</span><br><span class="line">		//在unresolvedRootSlots中查找不属于同一个JobVertex的slot</span><br><span class="line">		SlotSharingManager.MultiTaskSlot multiTaskSlotFuture = slotSharingManager.getUnresolvedRootSlot(groupId);  // 为null</span><br><span class="line">		if (multiTaskSlotFuture == null) &#123;</span><br><span class="line">			//没有找到合适的可利用的的slot, 那么将去向ResurceNameger申请新的TaskManger, 这是最后一步</span><br><span class="line">			final CompletableFuture&lt;AllocatedSlot&gt; futureSlot = requestNewAllocatedSlot(</span><br><span class="line">				allocatedSlotRequestId,</span><br><span class="line">				slotProfile.getResourceProfile(),</span><br><span class="line">				allocationTimeout); //300s</span><br><span class="line">			//将新产生的futureSlot, 放入resolvedRootSlots中, 这样之后申请slot时, 该slot可以被共享。</span><br><span class="line">			multiTaskSlotFuture = slotSharingManager.createRootSlot(</span><br><span class="line">				multiTaskSlotRequestId,</span><br><span class="line">				futureSlot,</span><br><span class="line">				allocatedSlotRequestId);</span><br><span class="line">			futureSlot.whenComplete(</span><br><span class="line">				(AllocatedSlot allocatedSlot, Throwable throwable) -&gt; &#123;</span><br><span class="line">					final SlotSharingManager.TaskSlot taskSlot = slotSharingManager.getTaskSlot(multiTaskSlotRequestId);</span><br><span class="line">					if (taskSlot != null) &#123;</span><br><span class="line">						// still valid</span><br><span class="line">						if (!(taskSlot instanceof SlotSharingManager.MultiTaskSlot) || throwable != null) &#123;</span><br><span class="line">							taskSlot.release(throwable);</span><br><span class="line">						&#125; else &#123;</span><br><span class="line">							if (!allocatedSlot.tryAssignPayload(((SlotSharingManager.MultiTaskSlot) taskSlot))) &#123;</span><br><span class="line">								taskSlot.release(new FlinkException(&quot;Could not assign payload to allocated slot &quot; +</span><br><span class="line">									allocatedSlot.getAllocationId() + &apos;.&apos;));</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		return SlotSharingManager.MultiTaskSlotLocality.of(multiTaskSlotFuture, Locality.UNKNOWN);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>该函数主要逻辑如下:</p>
<ul>
<li>从resolvedRootSlots、unresolvedRootSlots中查找是否有可共享的slot。</li>
<li>若没有, 向ResourceManager申请TaskManager以获取slot。</li>
<li>将申请的slot信息也存放入unresolvedRootSlots中, 等成功申请后再存放入resolvedRootSlots。<br>我们再接着看是如何向ResourceManager申请TaskManager的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private CompletableFuture&lt;AllocatedSlot&gt; requestNewAllocatedSlot(</span><br><span class="line">		SlotRequestId slotRequestId,</span><br><span class="line">		ResourceProfile resourceProfile,</span><br><span class="line">		Time allocationTimeout) &#123;</span><br><span class="line">	final PendingRequest pendingRequest = new PendingRequest(</span><br><span class="line">		slotRequestId,</span><br><span class="line">		resourceProfile);</span><br><span class="line">	// register request timeout</span><br><span class="line">	FutureUtils  //30s超时</span><br><span class="line">		.orTimeout(pendingRequest.getAllocatedSlotFuture(), allocationTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)</span><br><span class="line">		.whenCompleteAsync(  //当结束完成时需要做的事情</span><br><span class="line">			(AllocatedSlot ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">				if (throwable instanceof TimeoutException) &#123;</span><br><span class="line">					timeoutPendingSlotRequest(slotRequestId);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			getMainThreadExecutor());</span><br><span class="line">	if (resourceManagerGateway == null) &#123;  // 为null</span><br><span class="line">		stashRequestWaitingForResourceManager(pendingRequest);  // 会跑到这里</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		requestSlotFromResourceManager(resourceManagerGateway, pendingRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	return pendingRequest.getAllocatedSlotFuture();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以看到:</p>
<ul>
<li>首先查看resourceManagerGateway是否连接上, 若没有连接上, 将请求暂时缓存起来, 待连接上之后再申请。</li>
<li>若已经初始化之后, 会去向ResourceManager申请TaskManager。<h3 id="缓存申请Slot的请求"><a href="#缓存申请Slot的请求" class="headerlink" title="缓存申请Slot的请求"></a>缓存申请Slot的请求</h3>大致思路是先缓存申请slot的请求, 直到flink ResourceManager注册完成后, 再去申请, 我们看下整体细节。首先去查看哪里开始对resourceManagerGateway进行初始化的。 首先回到最开始准备执行ExecutionGraph的时候:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    private Acknowledge startJobExecution(JobMasterId newJobMasterId) throws Exception &#123;</span><br><span class="line">	 //这里会开始尝试连接rm， 会去和resourceManager建立联系</span><br><span class="line">	startJobMasterServices();</span><br><span class="line">	resetAndScheduleExecutionGraph();</span><br><span class="line">    &#125;</span><br><span class="line">    private void startJobMasterServices() throws Exception &#123;</span><br><span class="line">	slotPool.start(getFencingToken(), getAddress());</span><br><span class="line">	// 这里比较重要，会进去启动申请tm的请求</span><br><span class="line">	reconnectToResourceManager(new FlinkException(&quot;Starting JobMaster component.&quot;));</span><br><span class="line">	// StandaloneLeaderRetrievalService</span><br><span class="line">	resourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在reconnectToResourceManager中, 会去尝试初始化, 调用connectToResourceManager:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void connectToResourceManager() &#123;</span><br><span class="line">		resourceManagerConnection = new ResourceManagerConnection( //很重要</span><br><span class="line">			log,</span><br><span class="line">			jobGraph.getJobID(),</span><br><span class="line">			resourceId,</span><br><span class="line">			getAddress(),</span><br><span class="line">			getFencingToken(),</span><br><span class="line">			resourceManagerAddress.getAddress(),</span><br><span class="line">			resourceManagerAddress.getResourceManagerId(),</span><br><span class="line">			scheduledExecutorService);</span><br><span class="line">		resourceManagerConnection.start();  //从这里进去，获取注册ResourceManger</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在ResourceManagerConnection中定义了onRegistrationSuccess, 会去调用establishResourceManagerConnection()函数, 我们进入resourceManagerConnection.start()看下如何建立注册的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   public void start() &#123;</span><br><span class="line">       // ResourceManagerConnection</span><br><span class="line">       final RetryingRegistration&lt;F, G, S&gt; newRegistrationn = createNewRegistration();</span><br><span class="line">	if (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) &#123;</span><br><span class="line">	    //会从这里进去，很重要，比如注册ResourceManager</span><br><span class="line">		newRegistration.startRegistration();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在createNewRegistration中, 新建注册:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private RetryingRegistration&lt;F, G, S&gt; createNewRegistration() &#123;</span><br><span class="line">	RetryingRegistration&lt;F, G, S&gt; newRegistration = checkNotNull(generateRegistration());  //跑进去</span><br><span class="line">	CompletableFuture&lt;Tuple2&lt;G, S&gt;&gt; future = newRegistration.getFuture();</span><br><span class="line">	future.whenCompleteAsync(</span><br><span class="line">		(Tuple2&lt;G, S&gt; result, Throwable failure) -&gt; &#123;</span><br><span class="line">			if (failure != null) &#123;</span><br><span class="line">			......</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				targetGateway = result.f0;</span><br><span class="line">				//注意进来，进行pending task分配，调用ResourceManagerConnection.onRegistrationSuccess()</span><br><span class="line">				onRegistrationSuccess(result.f1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, executor);</span><br><span class="line">	return newRegistration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当注册完成并且没有抛出异常时, 说明注册完成了, 则调用之前的ResourceManagerConnection.onRegistrationSuccess()进行连接, 最终会进去SlotPool.connectToResourceManager()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) &#123;</span><br><span class="line">		// 开始申请之前被pending的请求</span><br><span class="line">		for (PendingRequest pendingRequest : waitingForResourceManager.values()) &#123;</span><br><span class="line">			requestSlotFromResourceManager(resourceManagerGateway, pendingRequest);</span><br><span class="line">		&#125;</span><br><span class="line">		waitingForResourceManager.clear();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当完成flink ResourceManager注册、连接后, 我们会逐个申请之前被挂起的请求。然后开始走之后描述的正常申请slot流程。</p>
<h3 id="向ResourceManager申请slot"><a href="#向ResourceManager申请slot" class="headerlink" title="向ResourceManager申请slot"></a>向ResourceManager申请slot</h3><p>从requestSlotFromResourceManager()中最终会进入registerSlotRequest</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   public boolean registerSlotRequest(SlotRequest slotRequest) throws SlotManagerException &#123;</span><br><span class="line">    PendingSlotRequest pendingSlotRequest = new PendingSlotRequest(slotRequest);</span><br><span class="line">	pendingSlotRequests.put(slotRequest.getAllocationId(), pendingSlotRequest);</span><br><span class="line">	try &#123;</span><br><span class="line">	    internalRequestSlot(pendingSlotRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">   &#125;</span><br><span class="line">   private void internalRequestSlot(PendingSlotRequest pendingSlotRequest) throws ResourceManagerException &#123;</span><br><span class="line">	//是否发现目前拥有的slot</span><br><span class="line">	TaskManagerSlot taskManagerSlot = findMatchingSlot(pendingSlotRequest.getResourceProfile());</span><br><span class="line">	if (taskManagerSlot != null) &#123;</span><br><span class="line">		allocateSlot(taskManagerSlot, pendingSlotRequest);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		resourceActions.allocateResource(pendingSlotRequest.getResourceProfile()); //跑到这里</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>internalRequestSlot做了如下逻辑:</p>
<ul>
<li>通过findMatchingSlot检查是否有现成可用的slot, 其中freeSlots包含着availiable slot. 比如在每当有新的TaskManager向JobManager注册时, 就会调用SlotManager.registerSlotRequest(), 在freeSlots中注册该TM可用的slot。若有可用slot时候, 就会调用allocateSlot进行分配。</li>
<li>若没有可用空闲slot, 通过allocateResource申请TM, 最终会调用YarnResourceManager.requestYarnContainer进行申请。<br>我们再分别以这两种情况继续介绍。<h4 id="JobManager端有某个TM注册的可用slot"><a href="#JobManager端有某个TM注册的可用slot" class="headerlink" title="JobManager端有某个TM注册的可用slot"></a>JobManager端有某个TM注册的可用slot</h4>若JM端有某个TM注册的可用slot, 那么就会进入allocateSlot来将这个slot分配给这个SubTask:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private void allocateSlot(TaskManagerSlot taskManagerSlot, PendingSlotRequest pendingSlotRequest) &#123;</span><br><span class="line">	TaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();</span><br><span class="line">	TaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();</span><br><span class="line"></span><br><span class="line">	final CompletableFuture&lt;Acknowledge&gt; completableFuture = new CompletableFuture&lt;&gt;();</span><br><span class="line">	final AllocationID allocationId = pendingSlotRequest.getAllocationId();</span><br><span class="line">	final SlotID slotId = taskManagerSlot.getSlotId();</span><br><span class="line">	final InstanceID instanceID = taskManagerSlot.getInstanceId();</span><br><span class="line"></span><br><span class="line">	taskManagerSlot.assignPendingSlotRequest(pendingSlotRequest);</span><br><span class="line">	pendingSlotRequest.setRequestFuture(completableFuture);</span><br><span class="line"></span><br><span class="line">	TaskManagerRegistration taskManagerRegistration = taskManagerRegistrations.get(instanceID);</span><br><span class="line">       // 既然这个TM上报的slot, 那么这个TM一定已经有注册信息了</span><br><span class="line">	if (taskManagerRegistration == null) &#123;</span><br><span class="line">		throw new IllegalStateException(&quot;Could not find a registered task manager for instance id &quot; +</span><br><span class="line">			instanceID + &apos;.&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	taskManagerRegistration.markUsed();</span><br><span class="line">	去向TM通信, 告诉TM这个slot已经被请求了</span><br><span class="line">	// RPC call to the task manager</span><br><span class="line">	CompletableFuture&lt;Acknowledge&gt; requestFuture = gateway.requestSlot(</span><br><span class="line">		slotId,</span><br><span class="line">		pendingSlotRequest.getJobId(),</span><br><span class="line">		allocationId,</span><br><span class="line">		pendingSlotRequest.getTargetAddress(),</span><br><span class="line">		resourceManagerId,</span><br><span class="line">		taskManagerRequestTimeout);</span><br><span class="line"></span><br><span class="line">	requestFuture.whenComplete(</span><br><span class="line">		(Acknowledge acknowledge, Throwable throwable) -&gt; &#123;</span><br><span class="line">			if (acknowledge != null) &#123;</span><br><span class="line">				completableFuture.complete(acknowledge);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	completableFuture.whenCompleteAsync(</span><br><span class="line">		(Acknowledge acknowledge, Throwable throwable) -&gt; &#123;</span><br><span class="line">			try &#123;  //去更新本地slot状态, 从可用空闲slot中删掉</span><br><span class="line">				if (acknowledge != null) &#123;</span><br><span class="line">					updateSlot(slotId, allocationId, pendingSlotRequest.getJobId());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				LOG.error(&quot;Error while completing the slot allocation.&quot;, e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		mainThreadExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>JM请求某个slot逻辑也比较简单:</p>
<ol>
<li>JM直接告诉slot对应TM, 这个slot将被申请</li>
<li>JM修改这个slot的状态, 并且从本地可用slot中删掉。然后等待subTask被部署到这个TM的slot上<br>我们看下第一步JM是怎么告诉TM这个slot被申请的,  gateway.requestSlot直接通过RPC(通信逻辑<a href="https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/#TM%E5%90%91JM%E6%B3%A8%E5%86%8C">参考</a>)直接向TM的TaskExecutor.requestSlot去了, 我们看下TM是如何做处理的:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   /**</span><br><span class="line"> * Add the given job to be monitored. This means that the service tries to detect leaders for</span><br><span class="line"> * this job and then tries to establish a connection to it.</span><br><span class="line"> */</span><br><span class="line">public CompletableFuture&lt;Acknowledge&gt; requestSlot(</span><br><span class="line">	final SlotID slotId,</span><br><span class="line">	final JobID jobId,</span><br><span class="line">	final AllocationID allocationId,</span><br><span class="line">	final String targetAddress,</span><br><span class="line">	final ResourceManagerId resourceManagerId,</span><br><span class="line">	final Time timeout) &#123;</span><br><span class="line">	log.info(&quot;Receive slot request &#123;&#125; for job &#123;&#125; from resource manager with leader id &#123;&#125;.&quot;,</span><br><span class="line">		allocationId, jobId, resourceManagerId);</span><br><span class="line">	try &#123;</span><br><span class="line">		if (taskSlotTable.isSlotFree(slotId.getSlotNumber())) &#123;</span><br><span class="line">			if (taskSlotTable.allocateSlot(slotId.getSlotNumber(), jobId, allocationId, taskManagerConfiguration.getTimeout())) &#123;</span><br><span class="line">				log.info(&quot;Allocated slot for &#123;&#125;.&quot;, allocationId);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (jobManagerTable.contains(jobId)) &#123;</span><br><span class="line">			offerSlotsToJobManager(jobId);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				jobLeaderService.addJob(jobId, targetAddress);  // 跑进去</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return CompletableFuture.completedFuture(Acknowledge.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>主要逻辑如下:</p>
<ol>
<li>TM接收到JM的请求后, TM首先检查这个slot是否是空闲的, 若空闲的话, 就开始调用taskSlotTable.allocateSlot(), 将这个slot置为已分配。</li>
<li>TM调用jobLeaderService.addJob将这个Job监控起来(每当有新的Job请求slot, 就会去检测job的leader, 并去和这个job leader建立链接),最终调用JobManagerLeaderListener.notifyLeaderAddress()-&gt;JobManagerRegisteredRpcConnection.start():<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   public void start() &#123;</span><br><span class="line">	checkState(!closed, &quot;The RPC connection is already closed&quot;);</span><br><span class="line">	checkState(!isConnected() &amp;&amp; pendingRegistration == null, &quot;The RPC connection is already started&quot;);</span><br><span class="line">	final RetryingRegistration&lt;F, G, S&gt; newRegistration = createNewRegistration();</span><br><span class="line">	if (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) &#123;</span><br><span class="line">		newRegistration.startRegistration();</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		// concurrent start operation</span><br><span class="line">		newRegistration.cancel();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里是不是有点熟悉, 可以参考下<a href="https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/#TM%E5%90%91JM%E6%B3%A8%E5%86%8C">这里</a>, startRegistration主要是向JM发送申请成功通知, TM成功后回调JobManagerRegisteredRpcConnection.onRegistrationSuccess, 最终调用TaskExecutor.establishJobManagerConnection:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private void establishJobManagerConnection(JobID jobId, final JobMasterGateway jobMasterGateway, JMTMRegistrationSuccess registrationSuccess) &#123;</span><br><span class="line">	if (jobManagerTable.contains(jobId)) &#123;</span><br><span class="line">		JobManagerConnection oldJobManagerConnection = jobManagerTable.get(jobId);</span><br><span class="line"></span><br><span class="line">		if (Objects.equals(oldJobManagerConnection.getJobMasterId(), jobMasterGateway.getFencingToken())) &#123;</span><br><span class="line">			// we already are connected to the given job manager</span><br><span class="line">			log.debug(&quot;Ignore JobManager gained leadership message for &#123;&#125; because we are already connected to it.&quot;, jobMasterGateway.getFencingToken());</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ResourceID jobManagerResourceID = registrationSuccess.getResourceID();</span><br><span class="line">	JobManagerConnection newJobManagerConnection = associateWithJobManager(</span><br><span class="line">			jobId,</span><br><span class="line">			jobManagerResourceID,</span><br><span class="line">			jobMasterGateway);</span><br><span class="line">	jobManagerConnections.put(jobManagerResourceID, newJobManagerConnection);</span><br><span class="line">	jobManagerTable.put(jobId, newJobManagerConnection);  // 设置的是每个Job在TM这里的注册</span><br><span class="line"></span><br><span class="line">	// monitor the job manager as heartbeat target</span><br><span class="line">	jobManagerHeartbeatManager.monitorTarget(jobManagerResourceID, new HeartbeatTarget&lt;AccumulatorReport&gt;() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void receiveHeartbeat(ResourceID resourceID, AccumulatorReport payload) &#123;</span><br><span class="line">			jobMasterGateway.heartbeatFromTaskManager(resourceID, payload);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void requestHeartbeat(ResourceID resourceID, AccumulatorReport payload) &#123;</span><br><span class="line">			// request heartbeat will never be called on the task manager side</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	offerSlotsToJobManager(jobId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了如下事情:</p>
<ol>
<li>检查这个job是否已经在TM端注册了, 若注册了, 那么就直接返回</li>
<li>否则建立job-&gt;JobManagerConnection, 将映射关系放入TaskExecutor的jobManagerTable中, 然后监控这个job master。</li>
<li>调用offerSlotsToJobManager, 告诉JM, 分配给Task这个slot。</li>
</ol>
<h4 id="JobManager端没有TM注册的可用slot"><a href="#JobManager端没有TM注册的可用slot" class="headerlink" title="JobManager端没有TM注册的可用slot"></a>JobManager端没有TM注册的可用slot</h4><p>若没有可用slot的话, 那么就只能去申请TM, 申请的TM会上报可用slot, 然后再向这个TM申请部署SubTask, 此时就回到了有可用slot的情况了。我们看下是如何申请TM的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   // //resource 是当前申请的container情况，比如&lt;memory:6552, vCores:4&gt;</span><br><span class="line">   private void requestYarnContainer(Resource resource, Priority priority) &#123;</span><br><span class="line">       //获取当前实际正在申请的slot个数</span><br><span class="line">	int pendingSlotRequests = getNumberPendingSlotRequests();</span><br><span class="line">	// 通过当前正在申请的Contaainer个数*numberOfTaskSlots计算出预计当前正在申请的slot个数</span><br><span class="line">	int pendingSlotAllocation = numPendingContainerRequests * numberOfTaskSlots;</span><br><span class="line">	//若当前实际申请的slot个数 &gt; 预计申请的slot个数, 那么需要去申请新的container, 来满足实际申请的slot个数</span><br><span class="line">	if (pendingSlotRequests &gt; pendingSlotAllocation) &#123;</span><br><span class="line">	    // 向yarn 发送申请container的请求。</span><br><span class="line">		resourceManagerClient.addContainerRequest(new AMRMClient.ContainerRequest(resource, null, null, priority));</span><br><span class="line">		resourceManagerClient.setHeartbeatInterval(FAST_YARN_HEARTBEAT_INTERVAL_MS);</span><br><span class="line">		//正在申请的container统计自增</span><br><span class="line">		numPendingContainerRequests++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="申请container成功"><a href="#申请container成功" class="headerlink" title="申请container成功"></a>申请container成功</h3><p>当向yarn成功申请到container之后, 会回调YarnResourceManager.onContainersAllocated通知jobManager。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void onContainersAllocated(List&lt;Container&gt; containers) &#123;</span><br><span class="line">	runAsync(() -&gt; &#123;</span><br><span class="line">		for (Container container : containers) &#123;</span><br><span class="line">			if (numPendingContainerRequests &gt; 0) &#123;</span><br><span class="line">				numPendingContainerRequests--;</span><br><span class="line">				final String containerIdStr = container.getId().toString();</span><br><span class="line">				final ResourceID resourceId = new ResourceID(containerIdStr);</span><br><span class="line">				workerNodeMap.put(resourceId, new YarnWorkerNode(container));</span><br><span class="line">				try &#123;</span><br><span class="line">					// 产生tm启动命令</span><br><span class="line">					ContainerLaunchContext taskExecutorLaunchContext = createTaskExecutorLaunchContext(</span><br><span class="line">						container.getResource(),</span><br><span class="line">						containerIdStr,</span><br><span class="line">						container.getNodeId().getHost());</span><br><span class="line">                      // 启动TaskManager</span><br><span class="line">					nodeManagerClient.startContainer(container, taskExecutorLaunchContext);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// if we are waiting for no further containers, we can go to the</span><br><span class="line">		// regular heartbeat interval</span><br><span class="line">		if (numPendingContainerRequests &lt;= 0) &#123;</span><br><span class="line">			resourceManagerClient.setHeartbeatInterval(yarnHeartbeatIntervalMillis);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回调函数主要做了如下逻辑:</p>
<ol>
<li>确定启动taskManager的命令。</li>
<li>通过yarn启动taskManager。<br>我们来放一张整体JobManager端分配Slot的流程图:<img src="https://kkewwei.github.io/elasticsearch_learning/img/Flink_slot_allocate1.png" height="300" width="800"></li>
</ol>
<h2 id="部署subTask到对应的slot"><a href="#部署subTask到对应的slot" class="headerlink" title="部署subTask到对应的slot"></a>部署subTask到对应的slot</h2><p>当确定好subTask部署到一个TaskManager的slot上之后, 在scheduleEager中就开始调用Execution.deploy()进行部署。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void deploy() throws JobException &#123;</span><br><span class="line">		final LogicalSlot slot  = assignedResource;  // SingleLogicalSlot</span><br><span class="line">		try &#123;</span><br><span class="line">			final TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(</span><br><span class="line">				attemptId,</span><br><span class="line">				slot, // SingleLogicalSlot</span><br><span class="line">				taskRestore,</span><br><span class="line">				attemptNumber);</span><br><span class="line">			// null taskRestore to let it be GC&apos;ed</span><br><span class="line">			taskRestore = null;</span><br><span class="line">			final TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway();</span><br><span class="line">			final CompletableFuture&lt;Acknowledge&gt; submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    public CompletableFuture&lt;Acknowledge&gt; submitTask(TaskDeploymentDescriptor tdd, Time timeout) &#123;</span><br><span class="line">        // 实际会去调用AkkaInvocationHandler，而去和tm通信，而不是跑到TaskExecutor.submitTask</span><br><span class="line">		return taskExecutorGateway.submitTask(tdd, jobMasterId, timeout);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到:</p>
<ul>
<li>首先生成TaskDeploymentDescriptor, 包含部署subTask的所有信息。</li>
<li>调用taskManagerGateway.submitTask(deployment, rpcTimeout)进行部署subTask, JM接收RPC可参考:<a href="https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/">link原理-Akka通信原理</a> 。<br>TaskManager端通过TaskExecutor.subTask()接受到JobManager发出的部署SubTask的申请, 这样就完成SubTask部署了。</li>
</ul>
<h1 id="SlotSharingGroup及共享slot"><a href="#SlotSharingGroup及共享slot" class="headerlink" title="SlotSharingGroup及共享slot"></a>SlotSharingGroup及共享slot</h1><p>Flink 允许相同SlotSharingGroup的subTask共享同一个slot, 好处主要有俩:</p>
<ul>
<li>A Flink cluster needs exactly as many task slots as the highest parallelism used in the job. No need to calculate how many tasks (with varying parallelism) a program contains in total.</li>
<li>It is easier to get better resource utilization. Without slot sharing, the non-intensive source&#x2F;map() subtasks would block as many resources as the resource intensive window subtasks. With slot sharing, increasing the base parallelism in our example from two to six yields full utilization of the slotted resources, while making sure that the heavy subtasks are fairly distributed among the TaskManagers.<br>默认情况下, SubTask使用相同的slot共享组: Default, task共享slot过程可以参考:<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html#task-slots-and-resources" target="_blank" rel="noopener">如何共享slot</a><br>这里将阐述SlotSharingGroup是如何生成并起作用的:<br>在JobGraph产生的时候调用setSlotSharingAndCoLocation()函数:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void setSlotSharingAndCoLocation() &#123;</span><br><span class="line">	final HashMap&lt;String, SlotSharingGroup&gt; slotSharingGroups = new HashMap&lt;&gt;();</span><br><span class="line">	for (Entry&lt;Integer, JobVertex&gt; entry : jobVertices.entrySet()) &#123;</span><br><span class="line">		final StreamNode node = streamGraph.getStreamNode(entry.getKey());</span><br><span class="line">		final JobVertex vertex = entry.getValue();// slotSharingGroupKey为默认值default</span><br><span class="line">		final String slotSharingGroupKey = node.getSlotSharingGroup();</span><br><span class="line">		final SlotSharingGroup sharingGroup;</span><br><span class="line">		if (slotSharingGroupKey != null) &#123;</span><br><span class="line">		    // 可以看到, 所有的task的group都为default, 都将放入到同一个SlotSharingGroup中</span><br><span class="line">			sharingGroup = slotSharingGroups.computeIfAbsent(slotSharingGroupKey, (k) -&gt; new SlotSharingGroup());</span><br><span class="line">			vertex.setSlotSharingGroup(sharingGroup);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			sharingGroup = null;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样, 所有的JobVertex都引用了同一个SlotSharingGroup。 而</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   public void setSlotSharingGroup(SlotSharingGroup grp) &#123;</span><br><span class="line">	if (this.slotSharingGroup != null) &#123;</span><br><span class="line">		this.slotSharingGroup.removeVertexFromGroup(id);</span><br><span class="line">	&#125;</span><br><span class="line">	this.slotSharingGroup = grp;</span><br><span class="line">	if (grp != null) &#123;</span><br><span class="line">		grp.addVertexToGroup(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个共享组的id都是相同的。</p>
<h1 id="MultiTaskSlot及SingleTaskSlot"><a href="#MultiTaskSlot及SingleTaskSlot" class="headerlink" title="MultiTaskSlot及SingleTaskSlot"></a>MultiTaskSlot及SingleTaskSlot</h1><p>MultiTaskSlot及SingleTaskSlot都继承TaskSlot, 每当subTask申请到一个未被共享的slot时, 就会产生一个MultiTaskSlot, 它代表着一个TM上的slot, 管理着该slot被共享的情况。 实际分配给每个subTask时, 会单独产生一个SingleTaskSlot, 然后每次被MultiTaskSlot管理着。之后若共享slot时, 分配到的都是同一个MultiTaskSlot, 不同的是每次每次分配都产生新的SingleTaskSlot。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html</a><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html" target="_blank" rel="noopener">https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html</a><br><a href="http://wuchong.me/blog/2016/05/03/flink-internals-overview/" target="_blank" rel="noopener">http://wuchong.me/blog/2016/05/03/flink-internals-overview/</a><br><a href="http://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/" target="_blank" rel="noopener">http://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">Flink、Slot分配、SubTask申请slot, SubTask部署</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/elasticsearch_learning/categories/Flink//" class="article-tag-list-link color1">Flink</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/elasticsearch_learning/2019/03/12/Flink原理-slot分配/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Netty对象回收池Recycler原理详解" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/elasticsearch_learning/2019/01/16/Netty对象回收池Recycler原理详解/">Netty对象回收池Recycler原理详解</a>
    </h1>
  

        
        <a href="/elasticsearch_learning/2019/01/16/Netty对象回收池Recycler原理详解/" class="archive-article-date">
  	<time datetime="2019-01-16T01:09:39.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-01-16</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>同Netty内存池(可参考<a href="https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/">Netty PoolArea原理探究</a>)一样, 为了增强Netty高性能并发能力, 减少通用对象分配的损耗, 也采用了对象池的概念。 当需要某个对象时, 首先从对象池中获取该对象, 当使用完成后, 将对象释放到对象池中, 这样达到重复使用对象的效果。基本使用如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Cycli &#123;</span><br><span class="line">    private static final Recycler&lt;Cycler&gt; CyclerRecycler = new Recycler&lt;Cycler&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected Cycler newObject(Handle&lt;Cycler&gt; handle) &#123;</span><br><span class="line">            return new Cycler(handle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    static final class Cycler &#123;</span><br><span class="line">        private String value;</span><br><span class="line">        public void setValue(String value) &#123;</span><br><span class="line">            this.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        private Recycler.Handle&lt;Cycler&gt; handle;</span><br><span class="line">        public Cycler(Recycler.Handle&lt;Cycler&gt; handle) &#123;</span><br><span class="line">            this.handle = handle;</span><br><span class="line">        &#125;</span><br><span class="line">        public void recycle() &#123;</span><br><span class="line">            handle.recycle(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void  main(String[] args) &#123;</span><br><span class="line">        // 1、从回收池获取对象</span><br><span class="line">        Cycler cycler1 = CyclerRecycler.get();</span><br><span class="line">        // 2、开始使用对象</span><br><span class="line">        cycler1.setValue(&quot;hello,java&quot;);</span><br><span class="line">        // 3、回收对象到对象池</span><br><span class="line">        cycler1.recycle();</span><br><span class="line">        // 4、从回收池获取对象</span><br><span class="line">        Cycler cycler2 = CyclerRecycler.get();</span><br><span class="line">        //比较从对象池中获取的对象即为之前释放的对象</span><br><span class="line">        System.out.print(cycler1 == cycler2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用比较简单, 主要定义了如下几个对象:</p>
<ul>
<li>定义CyclerRecycler, 作为对象池的入口, 定义newObject()函数, 若对象池中没有可用对象, 则新建对象。</li>
<li>定义被回收的对象Cycler, 包含成员变量handle, 该handler与该对象和stack绑定的。</li>
<li>通过CyclerRecycler.get()从对象池中获取对象; 通过Cycler1.recycle()释放该对象到对象池。</li>
</ul>
<h2 id="WeakOrderQueue、Stack介绍"><a href="#WeakOrderQueue、Stack介绍" class="headerlink" title="WeakOrderQueue、Stack介绍"></a>WeakOrderQueue、Stack介绍</h2><p>对象池通过Recycler里面WeakOrderQueue、Stack 2个类来实现。 首先放一张图来展示一个stack中两者的关系:<br><img src="https://kkewwei.github.io/elasticsearch_learning/img/Netty_Cycler1.png" height="450" width="650"></p>
<ul>
<li>每个线程都拥有自己的对象池, 该对象池结构如上图所示, stack作为本线程对象池的核心, 通过FastThreadLocal来实现每个线程的本地化。</li>
<li>本线程回收本线程产生的对象时, 会将对象以DefaultHandle的形式存放在stack的elements数组中; 若本线程thread1回收其它线程thread2产生的对象时, 将该对象放到thread2对应stack的一个WeakOrderQueue的Link中。 也就是说一个WeakOrderQueue节点存放着一个其他线程帮着本线程回收本线程生产的对象。每个stack的WeakOrderQueue链表节点个数不能超过2<em>cpu, 可以通过io.netty.recycler.maxDelayedQueuesPerThread控制。 也就是说最多有2</em>cpu个线程帮着回收对象。</li>
<li>每个link存放的对象是有限的, Link中DefaultHandle[]最多存放16个对象。 若thread1回收thread2产生的对象装满了一个Link, 则会再产生一个link继续存放。</li>
<li>当前线程从对象池中拿对象时, 首先从stack的elements中获取, 若没有的话, 将尝试从当前WeakOrderQueue节点cursor的Link中的数组对象transfer到stack的elements, 再从stack的elements中获取对象。</li>
<li>stack的element数组最大长度32768, 可以通过io.netty.recycler.maxCapacityPerThread控制; 而Link节点中每个DefaultHandle数组默认长度16, 可以通过io.netty.recycler.linkCapacity控制;<br>通过elements及Link完成了整个对象池的构建。</li>
</ul>
<h1 id="从线程池获取对象"><a href="#从线程池获取对象" class="headerlink" title="从线程池获取对象"></a>从线程池获取对象</h1><p>通过调用Recycler.get()来完成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final T get() &#123;</span><br><span class="line">     // 若置为0, 将handle置为Noop_HANDLE, 代表着不被回收</span><br><span class="line">    if (maxCapacityPerThread == 0) &#123;</span><br><span class="line">        return newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取当前线程对应的Stack</span><br><span class="line">    Stack&lt;T&gt; stack = threadLocal.get();</span><br><span class="line">    // 从对象池获取对象</span><br><span class="line">    DefaultHandle&lt;T&gt; handle = stack.pop();</span><br><span class="line">    // 若对象池中没有对象,则调用子类的newObject方法创建新的对象</span><br><span class="line">    if (handle == null) &#123;</span><br><span class="line">        handle = stack.newHandle();</span><br><span class="line">        handle.value = newObject(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    return (T) handle.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了如下事情:</p>
<ul>
<li>首先获取本线程对应的唯一stack, 从该stack中获取对象。</li>
<li>若对象池中没有对象, 则主动调用newObject产生一个对象。同时完成了handle与对象、stack的绑定。<br>我们接下来看如何通过stack.pop()来从对象池中获取对象:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DefaultHandle&lt;T&gt; pop() &#123;</span><br><span class="line">    //统计着elements中存放的对象个数</span><br><span class="line">    int size = this.size;</span><br><span class="line">   //若elements没有可用对象</span><br><span class="line">    if (size == 0) &#123;</span><br><span class="line">        //就尝试从别的线程帮着回收的对象中转移一些到elements中, 也就是从WeakOrderQueue中转移一些数据出来</span><br><span class="line">        if (!scavenge()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        size = this.size;</span><br><span class="line">    &#125;</span><br><span class="line">    size --;</span><br><span class="line">    DefaultHandle ret = elements[size];</span><br><span class="line">    elements[size] = null;</span><br><span class="line">    //在stack的lastRecycledId及recycleId一定是相等的</span><br><span class="line">    if (ret.lastRecycledId != ret.recycleId) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;recycled multiple times&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ret.recycleId = 0;</span><br><span class="line">    ret.lastRecycledId = 0;</span><br><span class="line">    this.size = size;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>对象在从对象池中被获取时, recycleId及lastRecycledId都被清零。<br>我们看scavenge是如何回收内存的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">boolean scavenge() &#123;</span><br><span class="line">    //尝试从WeakOrderQueue中转移数据DefaultHandle到stack的elements中</span><br><span class="line">    if (scavengeSome()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // reset our scavenge cursor</span><br><span class="line">    prev = null;</span><br><span class="line">    cursor = head;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">boolean scavengeSome() &#123;</span><br><span class="line">     //cursor属性保存了上一次对WeakorderQueueu列表的浏览位置，每一次都从上一次的位置继续，这是一种FIFO的处理策略</span><br><span class="line">    WeakOrderQueue prev;</span><br><span class="line">    WeakOrderQueue cursor = this.cursor;</span><br><span class="line">    //若游标为null, 则是第一次从WeakorderQueueu链中获取元素</span><br><span class="line">    if (cursor == null) &#123;</span><br><span class="line">        prev = null;</span><br><span class="line">        cursor = head;</span><br><span class="line">        //若不存在任何WeakorderQueueu, 退出</span><br><span class="line">        if (cursor == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev = this.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean success = false;</span><br><span class="line">    //循环的不停地从WeakOrderQueue中找到一个可用的Link</span><br><span class="line">    do &#123;</span><br><span class="line">        //从WeakOrderQueue中转移数据到element数组中。</span><br><span class="line">        if (cursor.transfer(this)) &#123;</span><br><span class="line">            success = true;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        WeakOrderQueue next = cursor.next;</span><br><span class="line">        //如果当前处理的WeakOrderQueue所在的线程已经消亡，则尽可能的提取里面的数据，之后从列表中删除这个WeakOrderQueue。注意owner使用WeakReference&lt;Thread&gt;定义, 当线程消亡后, 通过cursor.owner.get()自然变为null</span><br><span class="line">        if (cursor.owner.get() == null) &#123;</span><br><span class="line">            // If the thread associated with the queue is gone, unlink it, after</span><br><span class="line">            // performing a volatile read to confirm there is no data left to collect.</span><br><span class="line">            // We never unlink the first queue, as we don&apos;t want to synchronize on updating the head.</span><br><span class="line">            //如果消亡的线程还有数据，</span><br><span class="line">            if (cursor.hasFinalData()) &#123;</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    //尽量将该线程对应的WeakOrderQueue里面link对应的对象迁移到elements中</span><br><span class="line">                    if (cursor.transfer(this)) &#123;</span><br><span class="line">                        success = true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           //将消亡的那个WeakOrderQueue从链中去掉</span><br><span class="line">            if (prev != null) &#123;</span><br><span class="line">                prev.setNext(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev = cursor;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = next;</span><br><span class="line">    &#125; while (cursor != null &amp;&amp; !success);</span><br><span class="line">    this.prev = prev;</span><br><span class="line">    this.cursor = cursor;</span><br><span class="line">    return success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若stack的elements中没有对象, 那么把对象从Link的DefautHandle[]中迁移到stack的elements中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">boolean transfer(Stack&lt;?&gt; dst) &#123;</span><br><span class="line">        Link head = this.head;</span><br><span class="line">        //WeakOrderQueue中整个Link链为空, 则直接退出</span><br><span class="line">        if (head == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //说明head已经被读取完了，需要将head指向当前WeakOrderQueue的下一个link</span><br><span class="line">        if (head.readIndex == LINK_CAPACITY) &#123;</span><br><span class="line">            if (head.next == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //当前链节点换头</span><br><span class="line">            this.head = head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //获取当前可读的下标</span><br><span class="line">        final int srcStart = head.readIndex;</span><br><span class="line">        //当前link write的下标</span><br><span class="line">        int srcEnd = head.get();</span><br><span class="line">        //总共可读长度</span><br><span class="line">        final int srcSize = srcEnd - srcStart;</span><br><span class="line">        if (srcSize == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //计算即将写到elements中起始与终点位置</span><br><span class="line">        final int dstSize = dst.size;</span><br><span class="line">        final int expectedCapacity = dstSize + srcSize;</span><br><span class="line">        //如果超过stack当前能装下的最大elements个数</span><br><span class="line">        if (expectedCapacity &gt; dst.elements.length) &#123;</span><br><span class="line">            //将stack的elements扩容</span><br><span class="line">            final int actualCapacity = dst.increaseCapacity(expectedCapacity);</span><br><span class="line">            srcEnd = min(srcStart + actualCapacity - dstSize, srcEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        if (srcStart != srcEnd) &#123;</span><br><span class="line">            final DefaultHandle[] srcElems = head.elements;</span><br><span class="line">            final DefaultHandle[] dstElems = dst.elements;</span><br><span class="line">            int newDstSize = dstSize;</span><br><span class="line">            //每个元素都开始从源迁移到目的地</span><br><span class="line">            for (int i = srcStart; i &lt; srcEnd; i++) &#123;</span><br><span class="line">                DefaultHandle element = srcElems[i];</span><br><span class="line">                //对象在被回收时, recycleId、lastRecycledId都是0, 若直接被会受到stack的element中时, recycleId=lastRecycledId=thread_id; 若被会受到Link中时, lastRecycledId被修改成当前thread_id, recycleId仍为0, 当元素从Link迁移至stack的elements时, recycleId=astRecycledId。</span><br><span class="line">                if (element.recycleId == 0) &#123;</span><br><span class="line">                    element.recycleId = element.lastRecycledId;</span><br><span class="line">                &#125; else if (element.recycleId != element.lastRecycledId) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;recycled already&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                srcElems[i] = null;</span><br><span class="line">                //为了防止stack的elements扩张太快, 实际每8个迁移的对象中只取1个, 7个都被丢弃了</span><br><span class="line">                if (dst.dropHandle(element)) &#123;</span><br><span class="line">                    // Drop the object.</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                element.stack = dst;</span><br><span class="line">                dstElems[newDstSize ++] = element;</span><br><span class="line">            &#125;</span><br><span class="line">            // 若当前WeakOrderQueue的head已经被迁移完了, 需要从队列中抛弃</span><br><span class="line">            if (srcEnd == LINK_CAPACITY &amp;&amp; head.next != null) &#123;</span><br><span class="line">                // Add capacity back as the Link is GCed.</span><br><span class="line">                //增加每个线程帮另一个线程最多回收的限制</span><br><span class="line">                reclaimSpace(LINK_CAPACITY);</span><br><span class="line">                this.head = head.next; //当前WeakOrderQueue更新head</span><br><span class="line">            &#125;</span><br><span class="line">            //更新该head对象可读下标</span><br><span class="line">            head.readIndex = srcEnd;</span><br><span class="line">            if (dst.size == newDstSize) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            //更新stack可用对象的个数</span><br><span class="line">            dst.size = newDstSize;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // The destination stack is full already.</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从对象池中获取对象步骤总结如下:</p>
<ol>
<li>检查stack的elements中是否有可剩余的DefaultHandle。</li>
<li>若没有的话, 从cursor的head开始查找当前WeakorderQueue, 并检查WeakorderQueue对应的线程是否还存活着, 若对应的帮着回收的线程不再了, 则调用transfer将该WeakorderQueue对应的所有link中的数组循环迁移到elements中, 迁移的时候每8个丢弃7个, 只有一个被回收。</li>
<li>若对应线程还存活着, 则调用transfer进行回收当前WeakorderQueue中的一个link的所有DefaultHandle[]到stack的elements中。</li>
</ol>
<h1 id="向对象池中存放对象"><a href="#向对象池中存放对象" class="headerlink" title="向对象池中存放对象"></a>向对象池中存放对象</h1><p>如上例所示, 释放对象时调用cycler1.recycle()即可, 最终会调用与当前对象绑定的stack.push():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void push(DefaultHandle&lt;?&gt; item) &#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    //如果本线程就是产生对象的那个县城，那么直接把该对象放到stack的elements数组里</span><br><span class="line">    if (thread == currentThread) &#123;</span><br><span class="line">        // The current Thread is the thread that belongs to the Stack, we can try to push the object now.</span><br><span class="line">        pushNow(item);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // The current Thread is not the one that belongs to the Stack, we need to signal that the push</span><br><span class="line">        // happens later.</span><br><span class="line">        //如果该stack不是本线程的stack，那么把该DefaultHandle放到该stack的WeakOrderQueue中</span><br><span class="line">        pushLater(item, currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若回收对象的线程就是产生对象的线程, 那么直接将对象放到本stack对应的elements中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void pushNow(DefaultHandle&lt;?&gt; item) &#123;</span><br><span class="line">    if ((item.recycleId | item.lastRecycledId) != 0) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;recycled already&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    #俩都直接赋值相等, 则说明对象处于stack的elements中等待被读取。</span><br><span class="line">    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</span><br><span class="line">    int size = this.size;</span><br><span class="line">    //在push到对象池时, 也会丢弃7/8的元素</span><br><span class="line">    if (size &gt;= maxCapacity || dropHandle(item)) &#123;</span><br><span class="line">        // Hit the maximum capacity or should drop - drop the possibly youngest object.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //直接把DefaultHandle放到stack的数组里，如果数组满了那么扩展该数组为当前2倍大小</span><br><span class="line">    if (size == elements.length) &#123;</span><br><span class="line">        elements = Arrays.copyOf(elements, min(size &lt;&lt; 1, maxCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">    elements[size] = item;</span><br><span class="line">    this.size = size + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接存放对象时, 对象池也会丢弃7&#x2F;8的对象。<br>若回收对象的线程不是产生对象的线程, 我们来看下是如何将对象放到Link的数组中的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void pushLater(DefaultHandle&lt;?&gt; item, Thread thread) &#123;</span><br><span class="line">         // we don&apos;t want to have a ref to the queue as the value in our weak map</span><br><span class="line">         // so we null it out; to ensure there are no races with restoring it later</span><br><span class="line">         // we impose a memory ordering here (no-op on x86)</span><br><span class="line">         //DELAYED_RECYCLED里存放了当前线程向所有stack中插入的WeakOrderQueue的映射关系</span><br><span class="line">         Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</span><br><span class="line">         //获取到当前线程向stack插入的WeakOrderQueue节点</span><br><span class="line">         WeakOrderQueue queue = delayedRecycled.get(this);</span><br><span class="line">         if (queue == null) &#123;</span><br><span class="line">             //每个stack/线程最多能向maxDelayedQueues（2*cpu）个线程的WeakOrderQueue队列添加回收的的对象</span><br><span class="line">             if (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;//如果已经向maxDelayedQueues个线程插入过数据, 那么将1个伪造的WeakOrderQueue（DUMMY）放到delayedRecycled中，并丢弃该对象（DefaultHandle）</span><br><span class="line">                 // Add a dummy queue so we know we should drop the object</span><br><span class="line">                 delayedRecycled.put(this, WeakOrderQueue.DUMMY);</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">             // Check if we already reached the maximum number of delayed queues and if we can allocate at all.</span><br><span class="line">            //别的线程最多向这个stack的WeakOrderQueue插入16384个对象, 检查是否可以插入, 若可以插入, 就向这个stack头插法新建WeakOrderQueue对象</span><br><span class="line">             if ((queue = WeakOrderQueue.allocate(this, thread)) == null) &#123;</span><br><span class="line">                 // drop object</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">             delayedRecycled.put(this, queue);</span><br><span class="line">          //已经插入满了</span><br><span class="line">         &#125; else if (queue == WeakOrderQueue.DUMMY) &#123;</span><br><span class="line">             // drop object</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         queue.add(item); //向WeakOrderQueue对应的Link插入对象</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>DELAYED_RECYCLED实际保存的是每个线程向别的stack插入WeakOrderQueue的对应关系, 下图是一个线程保存向别的stack插入WeakOrderQueue的映射关系。<br><img src="https://kkewwei.github.io/elasticsearch_learning/img/Netty_Cycler2.png" height="350" width="450"><br>找到对应的WeakOrderQueue后, 调用add向对应的Link中插入对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void add(DefaultHandle&lt;?&gt; handle) &#123;</span><br><span class="line">    //这里仅仅修改lastRecycledId值, recycledId的修改时从WeakOrderQueue的link迁移到stack的elements的时候</span><br><span class="line">    handle.lastRecycledId = id;</span><br><span class="line">    Link tail = this.tail;</span><br><span class="line">    int writeIndex;</span><br><span class="line">    //若当前Link已经写满了, 那么我们再新一个Link存放对象</span><br><span class="line">    if ((writeIndex = tail.get()) == LINK_CAPACITY) &#123;</span><br><span class="line">        if (!reserveSpace(availableSharedCapacity, LINK_CAPACITY)) &#123;</span><br><span class="line">            // Drop it.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // We allocate a Link so reserve the space</span><br><span class="line">        this.tail = tail = tail.next = new Link();</span><br><span class="line">        writeIndex = tail.get();</span><br><span class="line">    &#125;</span><br><span class="line">    tail.elements[writeIndex] = handle;</span><br><span class="line">    //本Link所处的stack即为handle.stack。在对象池中可以清空, 在被转移到stack的elements时重新赋值。</span><br><span class="line">    handle.stack = null;</span><br><span class="line">    // we lazy set to ensure that setting stack to null appears before we unnull it in the owning thread;</span><br><span class="line">    // this also means we guarantee visibility of an element in the queue if we see the index updated</span><br><span class="line">   //修改内存偏移地址为8的值，但是修改后不保证立马能被其他的线程看到。</span><br><span class="line">    tail.lazySet(writeIndex + 1);  //https://github.com/netty/netty/issues/8215</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, 向Link中插入对象时, 仅改变对象的lastRecycledId值, 而没有改变recycledId值。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Netty回收对象也不是把所有对象全部回收, 为了防止回收对象过多, 会在直接存入stack的elements和从Link转移到stack的elements时会丢弃7&#x2F;8的废弃对象。Netty中使用对象回收的地方很多, 一个高频使用就是PooledUnsafeDirectByteBuf, 首先申请16M内存作为内存池时, 按需分配小的内存块, 这些小内存块都会被PooledUnsafeDirectByteBuf管理着。 而减少PooledUnsafeDirectByteBuf对象创建次数, 也增强了netty高性能传输数据的能力。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color2">Cycler</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/elasticsearch_learning/categories/Netty//" class="article-tag-list-link color1">Netty</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/elasticsearch_learning/2019/01/16/Netty对象回收池Recycler原理详解/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/elasticsearch_learning/">&laquo; Prev</a><a class="page-number" href="/elasticsearch_learning/">1</a><span class="page-number current">2</span><a class="page-number" href="/elasticsearch_learning/page/3/">3</a><a class="page-number" href="/elasticsearch_learning/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/elasticsearch_learning/page/6/">6</a><a class="extend next" rel="next" href="/elasticsearch_learning/page/3/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2022 jianguo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		toc_hide_index: true,
		root: "/elasticsearch_learning/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/elasticsearch_learning/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/elasticsearch_learning/slider.e37972.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">_cat/nodes接口</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">ES, Semgent Merge</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Flink、Slot分配、SubTask申请slot, SubTask部署</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Linux, close</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">NIO, write, read</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">NIO</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">LockSupport</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Lucene、ByteBlockPool</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">Lucene、词典、tim、tip、doc、pos、fst、倒排索引</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Lucene、词典、FST</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">Lucene、StoredField</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">Lucene、BKW树、Point</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Lucene、DocValue</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">PoolArena</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">Cycler</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">NioEventLoop</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">ReentrantLock</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">netty4, ServerBootstrap, Initiale</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">随笔</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">gdb</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">git, rebase, cherry-pick, reset, checkout</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">perftools、jcmd、pmap</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">maven, 插件, 打包</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接1</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">往事随风&lt;br&gt;&lt;br&gt;当才华满足不了你的梦想的时候，你就应该好好学习</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>